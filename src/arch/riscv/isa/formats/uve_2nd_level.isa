/////////////////////////////////
//
// Uve 2nd level decoder
// -----------------
// Jo√£o Domingos
//

output decoder {{
namespace Uve
{

    // JMNOTE: TO change
    StaticInstPtr
    decodeVectorLoad(ExtMachInst machInst)
    {
        uint8_t vector_dest = (uint8_t) bits(machInst, 11, 7);
        uint8_t base_addr = (uint8_t) bits(machInst, 19, 15);
        uint8_t size = (uint8_t) bits(machInst, 24, 20);
        bool s_bit = bits(machInst,25) ? true : false;

        //Args are: uint8_t _VDest, uint8_t _RS1, uint8_t _RS2

        if(!s_bit) {
            return decodeVectorLoadTemplated<UveMemLoad>(
            bits(machInst, 13, 12), machInst, vector_dest, base_addr, size);
        }
        else {
            return decodeVectorLoadTemplated<UveMemLoadSet>(
            bits(machInst, 13, 12), machInst, vector_dest, base_addr, size);
        }

    }  // decodeVectorLoad

    StaticInstPtr
    decodeVectorStore(ExtMachInst machInst){
        uint8_t vector_src = (uint8_t) bits(machInst, 11, 7);
        uint8_t base_addr = (uint8_t) bits(machInst, 19, 15);
        uint8_t size = (uint8_t) bits(machInst, 24, 20);
        bool s_bit = bits(machInst,25) ? true : false;

        //Args are: uint8_t _VSrc1, uint8_t _RS1, uint8_t _RS2

        if(!s_bit) {
            return decodeVectorStoreTemplated<UveMemStore>(
            machInst, vector_src, base_addr, size);
        }
        else {
            return decodeVectorStoreTemplated<UveMemStoreSet>(
            machInst, vector_src, base_addr, size);
        }
    }

    StaticInstPtr
    decodeVectorDup(ExtMachInst machInst){
        uint8_t vector_dest =(uint8_t) bits(machInst, 11, 7);
        uint8_t reg_src = (uint8_t) bits(machInst, 19, 15);
        uint8_t preg = (uint8_t) bits(machInst, 22, 20);

        return decodeVectorDupTemplated<UveVectorDup>(
        bits(machInst, 13, 12), machInst, vector_dest, reg_src, preg);
    }

    StaticInstPtr
    decodeVectorMoveSV(ExtMachInst machInst){
        uint8_t vector_dest =(uint8_t) bits(machInst, 11, 7);
        uint8_t reg_src = (uint8_t) bits(machInst, 19, 15);

        return decodeVectorMoveSVTemplated<UveVectorMoveSV>(
        bits(machInst, 13, 12), machInst, vector_dest, reg_src);
    }

    StaticInstPtr
    decodeVectorMove(ExtMachInst machInst){
        uint8_t vector_dest =(uint8_t) bits(machInst, 11, 7);
        uint8_t vector_src = (uint8_t) bits(machInst, 19, 15);
        uint8_t preg = (uint8_t) bits(machInst, 22, 20);

        if(bits(machInst, 23)==0)
            return decodeVectorMoveTemplated<UveVectorMove>(machInst,
                vector_dest, vector_src, preg);
        else
            return decodeVectorMoveTemplated<UveVectorMoveT>(machInst,
                vector_dest, vector_src, preg);

    }

    StaticInstPtr
    decodeVectorMoveVS(ExtMachInst machInst){
        uint8_t reg_dest =(uint8_t) bits(machInst, 11, 7);
        uint8_t vector_src = (uint8_t) bits(machInst, 19, 15);
        //JMTODO: Refactor
        return decodeVectorMoveVSTemplated<UveVectorMoveVS>(machInst,
            reg_dest, vector_src);
    }

    StaticInstPtr
    decodeVectorConv(ExtMachInst machInst){
        uint8_t vector_dest =(uint8_t) bits(machInst, 11, 7);
        uint8_t vector_src = (uint8_t) bits(machInst, 19, 15);

        //Selects FP, Unsigned and Signed
        uint8_t values_type = (uint8_t) bits(machInst, 24, 23);

        switch (values_type)
        {
        case 0x0:
            return decodeVectorConvTemplatedUnsigned<UveVectorConvUnsigned>(
            bits(machInst, 13, 12), machInst, vector_dest, vector_src);
            break;
        case 0x1:
            return decodeVectorConvTemplatedSigned<UveVectorConvSigned>(
            bits(machInst, 13, 12), machInst, vector_dest, vector_src);
            break;
        default:
            return decodeVectorConvTemplatedFP<UveVectorConvFP>(
            bits(machInst, 13, 12), machInst, vector_dest, vector_src);
            break;
        }
    }

} // namespace Uve

}};
