/////////////////////////////////
//
// Uve 2nd level decoder
// -----------------
// Jo√£o Domingos
//

output decoder {{

//Vector Move and Mem Instructions
namespace Uve
{

    StaticInstPtr
    decodeVectorLoad(ExtMachInst machInst)
    {
        uint8_t vector_dest = (uint8_t) bits(machInst, 11, 7);
        uint8_t base_addr = (uint8_t) bits(machInst, 19, 15);
        uint8_t size = (uint8_t) bits(machInst, 24, 20);
        bool s_bit = bits(machInst,25) ? true : false;

        //Args are: uint8_t _VDest, uint8_t _RS1, uint8_t _RS2

        if(!s_bit) {
            return decodeVectorLoadTemplated<UveMemLoad>(
            bits(machInst, 13, 12), machInst, vector_dest, base_addr, size);
        }
        else {
            return decodeVectorLoadTemplated<UveMemLoadSet>(
            bits(machInst, 13, 12), machInst, vector_dest, base_addr, size);
        }

    }  // decodeVectorLoad

    StaticInstPtr
    decodeVectorStore(ExtMachInst machInst){
        uint8_t vector_src = (uint8_t) bits(machInst, 11, 7);
        uint8_t base_addr = (uint8_t) bits(machInst, 19, 15);
        uint8_t size = (uint8_t) bits(machInst, 24, 20);
        bool s_bit = bits(machInst,25) ? true : false;

        //Args are: uint8_t _VSrc1, uint8_t _RS1, uint8_t _RS2

        if(!s_bit) {
            return decodeVectorStoreTemplated<UveMemStore>(
            machInst, vector_src, base_addr, size);
        }
        else {
            return decodeVectorStoreTemplated<UveMemStoreSet>(
            machInst, vector_src, base_addr, size);
        }
    }

    StaticInstPtr
    decodeVectorDup(ExtMachInst machInst){
        uint8_t vector_dest =(uint8_t) bits(machInst, 11, 7);
        uint8_t reg_src = (uint8_t) bits(machInst, 19, 15);
        uint8_t preg = (uint8_t) bits(machInst, 22, 20);

        return decodeVectorDupTemplated<UveVectorDup>(
        bits(machInst, 13, 12), machInst, vector_dest, reg_src, preg);
    }

    StaticInstPtr
    decodeVectorMoveSV(ExtMachInst machInst){
        uint8_t vector_dest =(uint8_t) bits(machInst, 11, 7);
        uint8_t reg_src = (uint8_t) bits(machInst, 19, 15);

        return decodeVectorMoveSVTemplated<UveVectorMoveSV>(
        bits(machInst, 13, 12), machInst, vector_dest, reg_src);
    }

    StaticInstPtr
    decodeVectorMove(ExtMachInst machInst){
        uint8_t vector_dest =(uint8_t) bits(machInst, 11, 7);
        uint8_t vector_src = (uint8_t) bits(machInst, 19, 15);
        uint8_t preg = (uint8_t) bits(machInst, 22, 20);

        if(bits(machInst, 23)==0)
            return decodeVectorMoveTemplated<UveVectorMove>(machInst,
                vector_dest, vector_src, preg);
        else
            return decodeVectorMoveTemplated<UveVectorMoveT>(machInst,
                vector_dest, vector_src, preg);

    }

    StaticInstPtr
    decodeVectorMoveVS(ExtMachInst machInst){
        uint8_t reg_dest =(uint8_t) bits(machInst, 11, 7);
        uint8_t vector_src = (uint8_t) bits(machInst, 19, 15);
        //JMTODO: Refactor
        return decodeVectorMoveVSTemplated<UveVectorMoveVS>(machInst,
            reg_dest, vector_src);
    }

    StaticInstPtr
    decodeVectorConv(ExtMachInst machInst){
        uint8_t vector_dest =(uint8_t) bits(machInst, 11, 7);
        uint8_t vector_src = (uint8_t) bits(machInst, 19, 15);

        //Selects FP, Unsigned and Signed
        uint8_t values_type = (uint8_t) bits(machInst, 24, 23);

        switch (values_type)
        {
        case 0x0:
            return decodeVectorConvTemplatedUnsigned<UveVectorConvUnsigned>(
            bits(machInst, 13, 12), machInst, vector_dest, vector_src);
            break;
        case 0x2:
            return decodeVectorConvTemplatedSigned<UveVectorConvSigned>(
            bits(machInst, 13, 12), machInst, vector_dest, vector_src);
            break;
        default:
            return decodeVectorConvTemplatedFP<UveVectorConvFP>(
            bits(machInst, 13, 12), machInst, vector_dest, vector_src);
            break;
        }
    }

} // namespace Uve


//Vector Arithmetic Instructions
namespace Uve
{
    StaticInstPtr
    decodeArithmetic(ExtMachInst machInst)
    {
        uint8_t dest = (uint8_t) bits(machInst, 11, 7);
        uint8_t src1 = (uint8_t) bits(machInst, 19, 15);
        uint8_t src2 = (uint8_t) bits(machInst, 24, 20);
        uint8_t pred = (uint8_t) bits(machInst, 27, 25);

        bool acc_bit = bits(machInst,20) ? true : false;
        uint8_t signed_fp = (uint8_t) bits(machInst, 13, 12);

        uint8_t top_decoder = (uint8_t) bits(machInst, 29, 28);
        uint8_t snd_decoder = (uint8_t) bits(machInst, 14);

        uint8_t decoder = top_decoder << 1 | snd_decoder;

        switch(decoder){
            case 0b000:
                return decodeThreeVecPredicatedFPTemplated
                    <UveArithAddUnsigned, UveArithAddSigned, UveArithAddFP>(
                    "so.a.add", signed_fp, machInst, dest, src1, src2, pred);
            break;
            case 0b001:
                return  decodeThreeVecPredicatedFPTemplated
                    <UveArithSubUnsigned, UveArithSubSigned, UveArithSubFP>(
                    "so.a.sub", signed_fp, machInst, dest, src1, src2, pred);
            break;
            case 0b010:
                return  decodeThreeVecPredicatedFPTemplated
                    <UveArithMulUnsigned, UveArithMulSigned, UveArithMulFP>(
                    "so.a.mul", signed_fp, machInst, dest, src1, src2, pred);
            break;
            case 0b011:
                return  decodeThreeVecPredicatedFPTemplated
                    <UveArithDivUnsigned, UveArithDivSigned, UveArithDivFP>(
                    "so.a.div", signed_fp, machInst, dest, src1, src2, pred);
            break;
            case 0b100:
                if(!acc_bit){
                    return  decodeTwoVecPredicatedFPTemplated
                        <UveArithAddeUnsigned, UveArithAddeSigned,
                        UveArithAddeFP>(
                        "so.a.adde", signed_fp, machInst,
                        dest, src1, pred);
                }
                else {
                    return  decodeTwoVecPredicatedFPTemplated
                        <UveArithAddeAccUnsigned, UveArithAddeAccSigned,
                        UveArithAddeAccFP>
                        ("so.a.adde", signed_fp, machInst,
                        dest, src1, pred);
                }
            break;
            case 0b101:
                if(!acc_bit){
                    return  decodeTwoVecPredicatedFPTemplated
                        <UveArithAddsUnsigned, UveArithAddsSigned,
                        UveArithAddsFP>(
                        "so.a.adds", signed_fp, machInst,
                        dest, src1, pred);
                }
                else {
                    return  decodeTwoVecPredicatedFPTemplated
                        <UveArithAddsAccUnsigned, UveArithAddsAccSigned,
                        UveArithAddsAccFP>
                        ("so.a.adds", signed_fp, machInst,
                        dest, src1, pred);
                }
            break;
            case 0b110:{
                uint8_t bit_13 = (uint8_t) bits(machInst,13);
                if(bit_13 == 0){
                    return  decodeTwoVecPredicatedFPoTemplated
                    <UveArithAbsSigned,UveArithAbsFP>(
                        "so.a.abs", signed_fp, machInst, dest, src1, pred);
                }
                else {
                    return new Unknown(machInst);
                    // return  decodeOneSrcVecTemplated<UveArithFlush>(
                    //     "so.a.flush", machInst, src1);
                }
            }
            break;
            case 0b111:
                return  decodeThreeVecPredicatedFPTemplated
                    <UveArithMacUnsigned, UveArithMacSigned, UveArithMacFP>(
                    "so.a.mac", signed_fp, machInst, dest, src1, src2, pred);
            break;
        }
        return new Unknown(machInst);
    }

    StaticInstPtr
    decodeLogic(ExtMachInst machInst)
    {
        uint8_t dest = (uint8_t) bits(machInst, 11, 7);
        uint8_t src1 = (uint8_t) bits(machInst, 19, 15);
        uint8_t src2 = (uint8_t) bits(machInst, 24, 20);
        uint8_t pred = (uint8_t) bits(machInst, 27, 25);

        uint8_t top_decoder = (uint8_t) bits(machInst, 28);
        uint8_t snd_decoder = (uint8_t) bits(machInst, 14, 12);

        if(top_decoder == 0) //Pure Logic Insts
            switch(snd_decoder){
                case 0b000:
                    return new UveArithNAND("so.a.nand",machInst,dest,src1,
                                        src2,pred);
                break;
                case 0b001:
                    return new UveArithAND("so.a.and",machInst,dest,src1,
                                        src2,pred);
                break;
                case 0b010:
                    return new UveArithNOR("so.a.nor",machInst,dest,src1,
                                        src2,pred);
                break;
                case 0b011:
                    return new UveArithOR("so.a.or",machInst,dest,src1,
                                        src2,pred);
                break;
                case 0b100:
                    return new UveArithNOT("so.a.not",machInst,dest,src1,
                                        pred);
                break;
                case 0b101:
                    return new UveArithXOR("so.a.xor",machInst,dest,src1,
                                        src2,pred);
                break;
            }
        else //Shift Insts
            switch(snd_decoder){
                case 0b000:
                    return new UveArithSLL("so.a.nand",machInst,dest,src1,
                                        src2,pred);
                break;
                case 0b001:
                    return new UveArithSLLS("so.a.nand",machInst,dest,src1,
                                        src2,pred);
                break;
                case 0b010:
                    return new UveArithSRL("so.a.nand",machInst,dest,src1,
                                        src2,pred);
                break;
                case 0b011:
                    return new UveArithSRLS("so.a.nand",machInst,dest,src1,
                                        src2,pred);
                break;
                case 0b100:
                    return new UveArithSRA("so.a.nand",machInst,dest,src1,
                                        src2,pred);
                break;
                case 0b101:
                    return new UveArithSRAS("so.a.nand",machInst,dest,src1,
                                        src2,pred);
                break;
            }
        return new Unknown(machInst);
    }

    StaticInstPtr
    decodeMisc(ExtMachInst machInst)
    {
        uint8_t dest = (uint8_t) bits(machInst, 11, 7);
        uint8_t src1 = (uint8_t) bits(machInst, 19, 15);
        uint8_t src2 = (uint8_t) bits(machInst, 24, 20);
        uint8_t pred = (uint8_t) bits(machInst, 27, 25);

        uint8_t signed_fp = (uint8_t) bits(machInst, 13, 12);

        uint8_t top_decoder = (uint8_t) bits(machInst, 29, 28);
        uint8_t snd_decoder = (uint8_t) bits(machInst, 14);

        uint8_t decoder = top_decoder << 1 | snd_decoder;

        switch(decoder){
            case 0b000:
                return decodeThreeVecPredicatedFPTemplated
                    <UveArithMinUnsigned, UveArithMinSigned, UveArithMinFP>(
                    "so.a.min", signed_fp, machInst, dest, src1, src2, pred);
            break;
            case 0b001:
                return  decodeThreeVecPredicatedFPTemplated
                    <UveArithMaxUnsigned, UveArithMaxSigned, UveArithMaxFP>(
                    "so.a.max", signed_fp, machInst, dest, src1, src2, pred);
            break;
            case 0b010:
                return  decodeTwoVecPredicatedFPTemplated
                    <UveArithMinsUnsigned, UveArithMinsSigned, UveArithMinsFP>(
                    "so.a.mins", signed_fp, machInst, dest, src1, pred);
            break;
            case 0b011:
                return  decodeTwoVecPredicatedFPTemplated
                    <UveArithMaxsUnsigned, UveArithMaxsSigned, UveArithMaxsFP>(
                    "so.a.maxs", signed_fp, machInst, dest, src1, pred);
            break;
            case 0b100:
                return  decodeTwoVecPredicatedFPTemplated
                    <UveArithIncUnsigned, UveArithIncSigned,
                    UveArithIncFP>
                    ("so.a.inc", signed_fp, machInst,
                    dest, src1, pred);
            break;
            case 0b101:
                return  decodeTwoVecPredicatedFPTemplated
                    <UveArithDecUnsigned, UveArithDecSigned,
                    UveArithDecFP>
                    ("so.a.dec", signed_fp, machInst,
                    dest, src1, pred);
            break;
        }
        return new Unknown(machInst);
    }
} // namespace Uve
}};
