/////////////////////////////////
//
// Uve 2nd level decoder
// -----------------
// Jo√£o Domingos
//

output decoder {{

//Vector Move and Mem Instructions
namespace Uve
{

    StaticInstPtr
    decodeVectorLoad(ExtMachInst machInst)
    {
        uint8_t vector_dest = (uint8_t) bits(machInst, 11, 7);
        uint8_t base_addr = (uint8_t) bits(machInst, 19, 15);
        uint8_t size = (uint8_t) bits(machInst, 24, 20);
        bool s_bit = bits(machInst,25) ? true : false;

        //Args are: uint8_t _VDest, uint8_t _RS1, uint8_t _RS2

        if(!s_bit) {
            return decodeVectorLoadTemplated<UveMemLoad>(
            bits(machInst, 13, 12), machInst, vector_dest, base_addr, size);
        }
        else {
            return decodeVectorLoadTemplated<UveMemLoadSet>(
            bits(machInst, 13, 12), machInst, vector_dest, base_addr, size);
        }

    }  // decodeVectorLoad

    StaticInstPtr
    decodeVectorStore(ExtMachInst machInst){
        uint8_t vector_src = (uint8_t) bits(machInst, 11, 7);
        uint8_t base_addr = (uint8_t) bits(machInst, 19, 15);
        uint8_t size = (uint8_t) bits(machInst, 24, 20);
        bool s_bit = bits(machInst,25) ? true : false;

        //Args are: uint8_t _VSrc1, uint8_t _RS1, uint8_t _RS2

        if(!s_bit) {
            return decodeVectorStoreTemplated<UveMemStore>(
            machInst, vector_src, base_addr, size);
        }
        else {
            return decodeVectorStoreTemplated<UveMemStoreSet>(
            machInst, vector_src, base_addr, size);
        }
    }

    StaticInstPtr
    decodeVectorDup(ExtMachInst machInst){
        uint8_t vector_dest =(uint8_t) bits(machInst, 11, 7);
        uint8_t reg_src = (uint8_t) bits(machInst, 19, 15);
        uint8_t preg = (uint8_t) bits(machInst, 22, 20);

        return decodeVectorDupTemplated<UveVectorDup>(
        bits(machInst, 13, 12), machInst, vector_dest, reg_src, preg);
    }

    StaticInstPtr
    decodeVectorMoveSV(ExtMachInst machInst){
        uint8_t vector_dest =(uint8_t) bits(machInst, 11, 7);
        uint8_t reg_src = (uint8_t) bits(machInst, 19, 15);

        return decodeVectorMoveSVTemplated<UveVectorMoveSV>(
        bits(machInst, 13, 12), machInst, vector_dest, reg_src);
    }

    StaticInstPtr
    decodeVectorMove(ExtMachInst machInst){
        uint8_t vector_dest =(uint8_t) bits(machInst, 11, 7);
        uint8_t vector_src = (uint8_t) bits(machInst, 19, 15);
        uint8_t preg = (uint8_t) bits(machInst, 22, 20);

        if(bits(machInst, 23)==0)
            return decodeVectorMoveTemplated<UveVectorMove>(machInst,
                vector_dest, vector_src, preg);
        else
            return decodeVectorMoveTemplated<UveVectorMoveT>(machInst,
                vector_dest, vector_src, preg);

    }

    StaticInstPtr
    decodeVectorMoveVS(ExtMachInst machInst){
        uint8_t reg_dest =(uint8_t) bits(machInst, 11, 7);
        uint8_t vector_src = (uint8_t) bits(machInst, 19, 15);
        //JMTODO: Refactor
        return decodeVectorMoveVSTemplated<UveVectorMoveVS>(machInst,
            reg_dest, vector_src);
    }

    StaticInstPtr
    decodeVectorConv(ExtMachInst machInst){
        uint8_t vector_dest =(uint8_t) bits(machInst, 11, 7);
        uint8_t vector_src = (uint8_t) bits(machInst, 19, 15);

        //Selects FP, Unsigned and Signed
        uint8_t values_type = (uint8_t) bits(machInst, 24, 23);

        switch (values_type)
        {
        case 0x0:
            return decodeVectorConvTemplatedUnsigned<UveVectorConvUnsigned>(
            bits(machInst, 13, 12), machInst, vector_dest, vector_src);
            break;
        case 0x2:
            return decodeVectorConvTemplatedSigned<UveVectorConvSigned>(
            bits(machInst, 13, 12), machInst, vector_dest, vector_src);
            break;
        default:
            return decodeVectorConvTemplatedFP<UveVectorConvFP>(
            bits(machInst, 13, 12), machInst, vector_dest, vector_src);
            break;
        }
    }

} // namespace Uve


//Vector Arithmetic Instructions
namespace Uve
{
    StaticInstPtr
    decodeArithmetic(ExtMachInst machInst)
    {
        uint8_t dest = (uint8_t) bits(machInst, 11, 7);
        uint8_t src1 = (uint8_t) bits(machInst, 19, 15);
        uint8_t src2 = (uint8_t) bits(machInst, 24, 20);
        uint8_t pred = (uint8_t) bits(machInst, 27, 25);

        bool acc_bit = bits(machInst,20) ? true : false;
        uint8_t signed_fp = (uint8_t) bits(machInst, 13, 12);

        uint8_t top_decoder = (uint8_t) bits(machInst, 29, 28);
        uint8_t snd_decoder = (uint8_t) bits(machInst, 14);

        uint8_t decoder = top_decoder << 1 | snd_decoder;

        switch(decoder){
            case 0b000:
                return decodeThreeVecPredicatedFPTemplated
                    <UveArithAddUnsigned, UveArithAddSigned, UveArithAddFP>(
                    "so.a.add", signed_fp, machInst, dest, src1, src2, pred);
            break;
            case 0b001:
                return  decodeThreeVecPredicatedFPTemplated
                    <UveArithSubUnsigned, UveArithSubSigned, UveArithSubFP>(
                    "so.a.sub", signed_fp, machInst, dest, src1, src2, pred);
            break;
            case 0b010:
                return  decodeThreeVecPredicatedFPTemplated
                    <UveArithMulUnsigned, UveArithMulSigned, UveArithMulFP>(
                    "so.a.mul", signed_fp, machInst, dest, src1, src2, pred);
            break;
            case 0b011:
                return  decodeThreeVecPredicatedFPTemplated
                    <UveArithDivUnsigned, UveArithDivSigned, UveArithDivFP>(
                    "so.a.div", signed_fp, machInst, dest, src1, src2, pred);
            break;
            case 0b100:
                if(!acc_bit){
                    return  decodeTwoVecPredicatedFPTemplated
                        <UveArithAddeUnsigned, UveArithAddeSigned,
                        UveArithAddeFP>(
                        "so.a.adde", signed_fp, machInst,
                        dest, src1, pred);
                }
                else {
                    return  decodeTwoVecPredicatedFPTemplated
                        <UveArithAddeAccUnsigned, UveArithAddeAccSigned,
                        UveArithAddeAccFP>
                        ("so.a.adde", signed_fp, machInst,
                        dest, src1, pred);
                }
            break;
            case 0b101:
                if(!acc_bit){
                    return  decodeTwoVecPredicatedFPTemplated
                        <UveArithAddsUnsigned, UveArithAddsSigned,
                        UveArithAddsFP>(
                        "so.a.adds", signed_fp, machInst,
                        dest, src1, pred);
                }
                else {
                    return  decodeTwoVecPredicatedFPTemplated
                        <UveArithAddsAccUnsigned, UveArithAddsAccSigned,
                        UveArithAddsAccFP>
                        ("so.a.adds", signed_fp, machInst,
                        dest, src1, pred);
                }
            break;
            case 0b110:{
                uint8_t bit_13 = (uint8_t) bits(machInst,13);
                if(bit_13 == 0){
                    return  decodeTwoVecPredicatedFPoTemplated
                    <UveArithAbsSigned,UveArithAbsFP>(
                        "so.a.abs", signed_fp, machInst, dest, src1, pred);
                }
                else {
                    return new Unknown(machInst);
                    // return  decodeOneSrcVecTemplated<UveArithFlush>(
                    //     "so.a.flush", machInst, src1);
                }
            }
            break;
            case 0b111:
                return  decodeThreeVecPredicatedFPTemplated
                    <UveArithMacUnsigned, UveArithMacSigned, UveArithMacFP>(
                    "so.a.mac", signed_fp, machInst, dest, src1, src2, pred);
            break;
        }
        return new Unknown(machInst);
    }

    StaticInstPtr
    decodeLogic(ExtMachInst machInst)
    {
        uint8_t dest = (uint8_t) bits(machInst, 11, 7);
        uint8_t src1 = (uint8_t) bits(machInst, 19, 15);
        uint8_t src2 = (uint8_t) bits(machInst, 24, 20);
        uint8_t pred = (uint8_t) bits(machInst, 27, 25);

        uint8_t top_decoder = (uint8_t) bits(machInst, 28);
        uint8_t snd_decoder = (uint8_t) bits(machInst, 14, 12);

        if(top_decoder == 0) //Pure Logic Insts
            switch(snd_decoder){
                case 0b000:
                    return new UveArithNAND("so.a.nand",machInst,dest,src1,
                                        src2,pred);
                break;
                case 0b001:
                    return new UveArithAND("so.a.and",machInst,dest,src1,
                                        src2,pred);
                break;
                case 0b010:
                    return new UveArithNOR("so.a.nor",machInst,dest,src1,
                                        src2,pred);
                break;
                case 0b011:
                    return new UveArithOR("so.a.or",machInst,dest,src1,
                                        src2,pred);
                break;
                case 0b100:
                    return new UveArithNOT("so.a.not",machInst,dest,src1,
                                        pred);
                break;
                case 0b101:
                    return new UveArithXOR("so.a.xor",machInst,dest,src1,
                                        src2,pred);
                break;
            }
        else //Shift Insts
            switch(snd_decoder){
                case 0b000:
                    return new UveArithSLL("so.a.nand",machInst,dest,src1,
                                        src2,pred);
                break;
                case 0b001:
                    return new UveArithSLLS("so.a.nand",machInst,dest,src1,
                                        src2,pred);
                break;
                case 0b010:
                    return new UveArithSRL("so.a.nand",machInst,dest,src1,
                                        src2,pred);
                break;
                case 0b011:
                    return new UveArithSRLS("so.a.nand",machInst,dest,src1,
                                        src2,pred);
                break;
                case 0b100:
                    return new UveArithSRA("so.a.nand",machInst,dest,src1,
                                        src2,pred);
                break;
                case 0b101:
                    return new UveArithSRAS("so.a.nand",machInst,dest,src1,
                                        src2,pred);
                break;
            }
        return new Unknown(machInst);
    }

    StaticInstPtr
    decodeMisc(ExtMachInst machInst)
    {
        uint8_t dest = (uint8_t) bits(machInst, 11, 7);
        uint8_t src1 = (uint8_t) bits(machInst, 19, 15);
        uint8_t src2 = (uint8_t) bits(machInst, 24, 20);
        uint8_t pred = (uint8_t) bits(machInst, 27, 25);

        uint8_t signed_fp = (uint8_t) bits(machInst, 13, 12);

        uint8_t top_decoder = (uint8_t) bits(machInst, 29, 28);
        uint8_t snd_decoder = (uint8_t) bits(machInst, 14);

        uint8_t decoder = top_decoder << 1 | snd_decoder;

        switch(decoder){
            case 0b000:
                return decodeThreeVecPredicatedFPTemplated
                    <UveArithMinUnsigned, UveArithMinSigned, UveArithMinFP>(
                    "so.a.min", signed_fp, machInst, dest, src1, src2, pred);
            break;
            case 0b001:
                return  decodeThreeVecPredicatedFPTemplated
                    <UveArithMaxUnsigned, UveArithMaxSigned, UveArithMaxFP>(
                    "so.a.max", signed_fp, machInst, dest, src1, src2, pred);
            break;
            case 0b010:
                return  decodeTwoVecPredicatedFPTemplated
                    <UveArithMinsUnsigned, UveArithMinsSigned, UveArithMinsFP>(
                    "so.a.mins", signed_fp, machInst, dest, src1, pred);
            break;
            case 0b011:
                return  decodeTwoVecPredicatedFPTemplated
                    <UveArithMaxsUnsigned, UveArithMaxsSigned, UveArithMaxsFP>(
                    "so.a.maxs", signed_fp, machInst, dest, src1, pred);
            break;
            case 0b100:
                return  decodeTwoVecPredicatedFPTemplated
                    <UveArithIncUnsigned, UveArithIncSigned,
                    UveArithIncFP>
                    ("so.a.inc", signed_fp, machInst,
                    dest, src1, pred);
            break;
            case 0b101:
                return  decodeTwoVecPredicatedFPTemplated
                    <UveArithDecUnsigned, UveArithDecSigned,
                    UveArithDecFP>
                    ("so.a.dec", signed_fp, machInst,
                    dest, src1, pred);
            break;
        }
        return new Unknown(machInst);
    }
} // namespace Uve


//Vector Predicate Instructions
namespace Uve
{
    StaticInstPtr
    decodePredicateControl(ExtMachInst machInst)
    {
        uint8_t dest = (uint8_t) bits(machInst, 10, 7);
        uint8_t src1 = (uint8_t) bits(machInst, 18, 15);
        uint8_t src1_vector = (uint8_t) bits(machInst, 19, 15);
        uint8_t src2_vector = (uint8_t) bits(machInst, 24, 20);
        uint8_t pred = (uint8_t) bits(machInst, 27, 25);

        // uint8_t width = (uint8_t) bits(machInst, 21, 20);

        uint8_t decoder = (uint8_t) bits(machInst, 14,11);

        switch(decoder){
            case 0b0000:
                return new UvePredZero("so.p.zero", machInst, dest, pred);
            case 0b0001:
                return new UvePredOne("so.p.one", machInst, dest, pred);
            // case 0b0010:
            //     return new UvePredVecReg("so.p.vr", machInst, dest,
            //         src1_vector, pred);
            case 0b0011:
                return new UvePredNot("so.p.not", machInst, dest,
                    src1, pred);

            case 0b0100:
                return new UvePredMove("so.p.mv", machInst, dest,
                        src1, pred);
            case 0b0101:
                return new UvePredMoveT("so.p.mvt", machInst, dest,
                    src1, pred);
            //     }
            // case 0b0110:
            //     return  decodePredicateInstTemplated<UvePredConv>
            //         ("so.p.cv", width, machInst,
            //         dest, src1);

            // EGTS
            case 0b1000:
                return new UvePredEGTSUnsigned("so.p.egts.us", machInst, dest,
                    src1_vector, src2_vector, pred);
            case 0b1010:
                return new UvePredEGTSFP("so.p.egts.fp", machInst, dest,
                    src1_vector, src2_vector, pred);
            case 0b1100:
                return new UvePredEGTSSigned("so.p.egts.sg", machInst, dest,
                    src1_vector, src2_vector, pred);

            // EGT
            case 0b1001:
                return new UvePredEGTUnsigned("so.p.egt.us", machInst, dest,
                    src1_vector, src2_vector, pred);
            case 0b1011:
                return new UvePredEGTFP("so.p.egt.fp", machInst, dest,
                    src1_vector, src2_vector, pred);
            case 0b1101:
                return new UvePredEGTSigned("so.p.egt.sg", machInst, dest,
                    src1_vector, src2_vector, pred);

        }
        return new Unknown(machInst);
    }

    StaticInstPtr
    decodePredicateLogic(ExtMachInst machInst)
    {
        uint8_t dest = (uint8_t) bits(machInst, 10, 7);
        uint8_t src1_vector = (uint8_t) bits(machInst, 19, 15);
        uint8_t src2_vector = (uint8_t) bits(machInst, 24, 20);
        uint8_t pred = (uint8_t) bits(machInst, 27, 25);

        uint8_t decoder = (uint8_t) bits(machInst, 14,11);

        switch(decoder){
            // EQS
            case 0b0000:
                return new UvePredEQSUnsigned("so.p.eqs.us", machInst, dest,
                    src1_vector, src2_vector, pred);
            case 0b0010:
                return new UvePredEQSFP("so.p.eqs.fp", machInst, dest,
                    src1_vector, src2_vector, pred);
            case 0b0100:
                return new UvePredEQSSigned("so.p.eqs.sg", machInst, dest,
                    src1_vector, src2_vector, pred);

            // EQ
            case 0b0001:
                return new UvePredEQUnsigned("so.p.eq.us", machInst, dest,
                    src1_vector, src2_vector, pred);
            case 0b0011:
                return new UvePredEQFP("so.p.eq.fp", machInst, dest,
                    src1_vector, src2_vector, pred);
            case 0b0101:
                return new UvePredEQSigned("so.p.eq.sg", machInst, dest,
                    src1_vector, src2_vector, pred);

            // LTS
            case 0b1000:
                return new UvePredLTSUnsigned("so.p.lts.us", machInst, dest,
                    src1_vector, src2_vector, pred);
            case 0b1010:
                return new UvePredLTSFP("so.p.lts.fp", machInst, dest,
                    src1_vector, src2_vector, pred);
            case 0b1100:
                return new UvePredLTSSigned("so.p.lts.sg", machInst, dest,
                    src1_vector, src2_vector, pred);

            // LT
            case 0b1001:
                return new UvePredLTUnsigned("so.p.lt.us", machInst, dest,
                    src1_vector, src2_vector, pred);
            case 0b1011:
                return new UvePredLTFP("so.p.lt.fp", machInst, dest,
                    src1_vector, src2_vector, pred);
            case 0b1101:
                return new UvePredLTSigned("so.p.lt.sg", machInst, dest,
                    src1_vector, src2_vector, pred);

        }
        return new Unknown(machInst);
    }


} // namespace Uve


//Stream Instructions
namespace Uve
{
    StaticInstPtr
    decodeStreamSimple(ExtMachInst machInst)
    {
        uint8_t stream = (uint8_t) bits(machInst, 11, 7);
        uint8_t offset = (uint8_t) bits(machInst, 19, 15);
        uint8_t size = (uint8_t) bits(machInst, 24, 20);
        uint8_t stride = (uint8_t) bits(machInst, 31, 27);

        uint8_t width = (uint8_t) bits(machInst, 13, 12);

        //Args are: uint8_t _VDest, uint8_t _RS1, uint8_t _RS2

        return decodeStreamTemplated<UveStream>(width, machInst,
            stream, offset, size, stride);

    }  // decodeStreamSimple

    StaticInstPtr
    decodeStreamStart(ExtMachInst machInst)
    {
        uint8_t stream = (uint8_t) bits(machInst, 11, 7);
        uint8_t offset = (uint8_t) bits(machInst, 19, 15);
        uint8_t size = (uint8_t) bits(machInst, 24, 20);
        uint8_t stride = (uint8_t) bits(machInst, 31, 27);

        uint8_t width = (uint8_t) bits(machInst, 13, 12);

        //Args are: uint8_t _VDest, uint8_t _RS1, uint8_t _RS2

        return decodeStreamTemplated<UveStreamSta>(width, machInst,
            stream, offset, size, stride);

    }  // decodeStreamStart

    StaticInstPtr
    decodeStreamAppend(ExtMachInst machInst)
    {
        uint8_t stream = (uint8_t) bits(machInst, 11, 7);
        uint8_t offset = (uint8_t) bits(machInst, 19, 15);
        uint8_t size = (uint8_t) bits(machInst, 24, 20);
        uint8_t stride = (uint8_t) bits(machInst, 31, 27);

        //Args are: uint8_t _VDest, uint8_t _RS1, uint8_t _RS2

        return new UveStreamApp("ss.app", machInst, stream, offset, size, stride);

    }  // decodeStreamAppend
    StaticInstPtr
    decodeStreamEnd(ExtMachInst machInst)
    {
        uint8_t stream = (uint8_t) bits(machInst, 11, 7);
        uint8_t offset = (uint8_t) bits(machInst, 19, 15);
        uint8_t size = (uint8_t) bits(machInst, 24, 20);
        uint8_t stride = (uint8_t) bits(machInst, 31, 27);

        //Args are: uint8_t _VDest, uint8_t _RS1, uint8_t _RS2

        return new UveStreamEnd("ss.end", machInst, stream, offset, size, stride);

    }  // decodeStreamEnd

} // namespace Uve

namespace Uve {
    StaticInstPtr
    decodeSBranchNC(ExtMachInst machInst)
    {
        uint8_t stream = (uint8_t) bits(machInst, 19, 15);
        uint64_t immediate = ((uint64_t) bits(machInst, 28) << 12)      |
                             ((uint64_t) bits(machInst, 7) << 11)       |
                             ((uint64_t) bits(machInst, 27, 22) << 5)   |
                             ((uint64_t) bits(machInst, 11, 8) << 1);

        return new UveSBranchNC("so.b.nc", machInst, stream,
                                sext<13>(immediate));

    }  // decodeSBranchNC
} // namespace Uve

}};
