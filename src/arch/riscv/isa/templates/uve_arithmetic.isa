//JMNOTE: Uve Arithmetic 3VecsPredicated Header Declaration Template

def template UveThreeVecPredicatedDeclare {{
    class %(class_name)s : public %(base_class)s
    {
      protected:
        typedef uint8_t TPElem;

      public:
        %(class_name)s(const char* mnem, ExtMachInst machInst,
            uint8_t _VDest, uint8_t _VSrc1, uint8_t _VSrc2,
            uint8_t _PSrc3)
            : %(base_class)s(mnem, machInst, %(op_class)s,
                _VDest, _VSrc1, _VSrc2, _PSrc3)
        {
            %(constructor)s;
        }

        Fault execute(ExecContext *, Trace::InstRecord *) const;
    };
}};

//JMNOTE: Uve Arithmetic 2VecsPredicated Header Declaration Template

def template UveTwoVecPredicatedDeclare {{
    class %(class_name)s : public %(base_class)s
    {
      protected:
        typedef uint8_t TPElem;

      public:
        %(class_name)s(const char* mnem, ExtMachInst machInst,
            uint8_t _VDest, uint8_t _VSrc1,
            uint8_t _PSrc3)
            : %(base_class)s(mnem, machInst, %(op_class)s,
                _VDest, _VSrc1, _PSrc3)
        {
            %(constructor)s;
        }

        Fault execute(ExecContext *, Trace::InstRecord *) const;
    };
}};

//JMNOTE: Uve Arithmetic 2Vecs to 1SDest Predicated Header Declaration Template

def template UveTwoVec2ScaPredicatedDeclare {{
    class %(class_name)s : public %(base_class)s
    {
      protected:
        typedef uint8_t TPElem;

      public:
        %(class_name)s(const char* mnem, ExtMachInst machInst,
            uint8_t _RD, uint8_t _VSrc1,
            uint8_t _PSrc3)
            : %(base_class)s(mnem, machInst, %(op_class)s,
                _RD, _VSrc1, _PSrc3)
        {
            %(constructor)s;
        }

        Fault execute(ExecContext *, Trace::InstRecord *) const;
    };
}};


//JMNOTE: Uve Arithmetic VecScaPredicated Header Declaration Template

def template UveVecScaPredicatedDeclare {{
    class %(class_name)s : public %(base_class)s
    {
      protected:
        typedef uint8_t TPElem;

      public:
        %(class_name)s(const char* mnem, ExtMachInst machInst,
            uint8_t _VDest, uint8_t _VSrc1, uint8_t _RD2,
            uint8_t _PSrc3)
            : %(base_class)s(mnem, machInst, %(op_class)s,
                _VDest, _VSrc1, _RD2, _PSrc3)
        {
            %(constructor)s;
        }

        Fault execute(ExecContext *, Trace::InstRecord *) const;
    };
}};

//JMNOTE: Generic Exec Declare Template Implementation Templates
//This expands templates, in order for the linkage process to work

def template UveArithExecDeclare {{
    Fault %(class_name)s::execute(ExecContext *,
        Trace::InstRecord *) const;
}};

//JMNOTE: 3Vec Pred Instruction Templates ([] = OP([], []))

def template UveThreeVecPredicatedExecute {{
    Fault %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        unsigned eCount = RiscvStaticInst::getCurUveVecLen(
            xc->tcBase()) / sizeof(uint8_t);
        std::fesetround(FE_TONEAREST); //JMNOTE: Note we are rounding to
            //Nearest here.. with conscience of the other possibilities

        %(op_decl)s;
        %(op_rd)s;

        if (fault == NoFault) {
            %(ex_code)s;
            %(op_wb)s;

            DPRINTF(UVEArith, "%(class_name)s->execute: eCount(%d) iCount(%d)"
            "\n", eCount, iCount);
        }

        return fault;
    }
}};


//JMNOTE: 2Vec Pred Instruction Templates  ([] =  OP([], []?) + []?)

def template UveTwoVecPredicatedExecute {{
    Fault %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {

        Fault fault = NoFault;
        unsigned eCount = RiscvStaticInst::getCurUveVecLen(
            xc->tcBase()) / sizeof(uint8_t);

        std::fesetround(FE_TONEAREST); //JMNOTE: Note we are rounding to
            //Nearest here.. with conscience of the other possibilities

        %(op_decl)s;
        %(op_rd)s;

        if (fault == NoFault) {
            %(ex_code)s;
            %(op_wb)s;

            DPRINTF(UVEArith, "%(class_name)s->execute: eCount(%d) iCount(%d)"
            "\n", eCount, iCount);
        }

        return fault;
    }
}};



//JMNOTE: 1/2Vec 1SDest Pred Instruction Templates (Sca = OP([], []?) + Sca?)

def template UveTwoVec2ScaPredicatedExecute {{
    Fault %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        unsigned eCount = RiscvStaticInst::getCurUveVecLen(
            xc->tcBase()) / sizeof(uint8_t);

        std::fesetround(FE_TONEAREST); //JMNOTE: Note we are rounding to
            //Nearest here.. with conscience of the other possibilities

        %(op_decl)s;
        %(op_rd)s;

        if (fault == NoFault) {
            %(ex_code)s;
            %(op_wb)s;

            DPRINTF(UVEArith, "%(class_name)s->execute: eCount(%d) iCount(%d)"
            "\n", eCount, iCount);
        }

        return fault;
    }
}};


//JMNOTE: VecSca Pred Instruction Templates ([] = [] << Sca)

def template UveVecScaPredicatedExecute {{
    Fault %(class_name)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        unsigned eCount = RiscvStaticInst::getCurUveVecLen(
            xc->tcBase()) / sizeof(uint8_t);

        std::fesetround(FE_TONEAREST); //JMNOTE: Note we are rounding to
            //Nearest here.. with conscience of the other possibilities

        %(op_decl)s;
        %(op_rd)s;


        if (fault == NoFault) {
            %(ex_code)s;
            %(op_wb)s;
            DPRINTF(UVEArith, "%(class_name)s->execute: eCount(%d) iCount(%d)
            "\n", eCount, iCount);
        }

        return fault;
    }
}};