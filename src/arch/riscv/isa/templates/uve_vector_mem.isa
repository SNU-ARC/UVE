/////////////////////////////////
//
// Uve vector memory operations templates definition
// -----------------
// JoÃ£o Domingos
//

//JMNOTE: Load/Store Header Declaration Templates

def template UveMemLoadDeclare {{
    %(tpl_header)s
    class %(class_name)s : public %(base_class)s
    {
      protected:
        typedef RegElemType TPElem;

      public:
        %(class_name)s(const char* mnem, ExtMachInst machInst,
            uint8_t _VDest, uint8_t _RS1,
            uint8_t _RS2)
            : %(base_class)s(mnem, machInst, %(op_class)s,
                _VDest, _RS1, _RS2)
        {
            %(constructor)s;
        }

        Fault execute(ExecContext *, Trace::InstRecord *) const;
        Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;
        Fault completeAcc(PacketPtr, ExecContext *, Trace::InstRecord *) const;

    };
}};

def template UveMemStoreDeclare {{
    %(tpl_header)s
    class %(class_name)s : public %(base_class)s
    {
      protected:
        typedef RegElemType TPElem;

      public:
        %(class_name)s(const char* mnem, ExtMachInst machInst,
            uint8_t _VSrc1, uint8_t _RS1,
            uint8_t _RS2)
            : %(base_class)s(mnem, machInst, %(op_class)s,
                _VSrc1, _RS1, _RS2)
        {
            %(constructor)s;
        }

        Fault execute(ExecContext *, Trace::InstRecord *) const;
        Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;
        Fault completeAcc(PacketPtr, ExecContext *, Trace::InstRecord *) const;

    };
}};

//JMNOTE: Load/Store Template Implementation Templates


def template UveMemExecDeclare {{
    template
    Fault %(class_name)s%(tpl_args)s::execute(ExecContext *,
        Trace::InstRecord *) const;

    template
    Fault %(class_name)s%(tpl_args)s::initiateAcc(ExecContext *,
        Trace::InstRecord *) const;

    template
    Fault %(class_name)s%(tpl_args)s::completeAcc(PacketPtr,
        ExecContext *, Trace::InstRecord *) const;
}};

//JMNOTE: Load Instruction Templates

def template UveLoadExecute {{
    %(tpl_header)s
    Fault %(class_name)s%(tpl_args)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;
        unsigned eCount = RiscvStaticInst::getCurUveVecLen(
            xc->tcBase());

        %(op_decl)s;
        %(op_rd)s;
        %(ea_code)s;

        TheISA::VecRegContainer memData;
        auto memDataView = memData.as<RegElemType>();

        %(rden_code)s;

        fault = xc->readMem(EA, memData.raw_ptr<uint8_t>(), memAccessSize,
            this->memAccessFlags, rdEn);

        if (fault == NoFault) {
            %(memacc_code)s;
            %(op_wb)s;
            %(set_update_base_address)s;
        }
        
        return fault;
    }
}};

def template UveLoadInitiateAcc {{
    %(tpl_header)s
    Fault %(class_name)s%(tpl_args)s::initiateAcc(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;
        unsigned eCount = ArmStaticInst::getCurSveVecLen<RegElemType>(
            xc->tcBase());

        %(op_src_decl)s;
        %(op_rd)s;
        %(ea_code)s;

        %(rden_code)s;

        fault = xc->initiateMemRead(EA, memAccessSize, this->memAccessFlags,
            rdEn);

        return fault;
    }
}};

def template UveLoadCompleteAcc {{
    %(tpl_header)s
    Fault %(class_name)s%(tpl_args)s::completeAcc(PacketPtr pkt,
        ExecContext *xc, Trace::InstRecord *traceData) const
    {
        unsigned eCount = RiscvStaticInst::getCurUveVecLen(
            xc->tcBase());

        %(op_decl)s;
        %(op_rd)s;

        TheISA::VecRegContainer memData;
        auto memDataView = memData.as<RegElemType>();

        if (xc->readMemAccPredicate()) {
            memcpy(memData.raw_ptr<uint8_t>(), pkt->getPtr<uint8_t>(),
                   pkt->getSize());
        }

        %(memacc_code)s;
        %(op_wb)s;
        %(set_update_base_address)s;

        return NoFault;
    }
}};

//JMNOTE: Store Instruction Templates

def template UveStoreExecute {{
    %(tpl_header)s
    Fault %(class_name)s%(tpl_args)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;
        unsigned eCount = RiscvStaticInst::getCurUveVecLen(
            xc->tcBase());

        %(op_decl)s;
        %(op_rd)s;
        %(ea_code)s;

        TheISA::VecRegContainer memData;
        auto memDataView = memData.as<RegElemType>();

        %(wren_code)s;

        if (fault == NoFault) {
            %(memacc_code)s;
        }

        if (fault == NoFault) {
            fault = xc->writeMem(memData.raw_ptr<uint8_t>(), memAccessSize, EA,
                this->memAccessFlags, NULL, wrEn);
        }

        if (fault == NoFault) {
            %(op_wb)s;
            %(set_update_base_address)s;
        }

        return fault;
    }
}};

def template UveStoreInitiateAcc {{
    %(tpl_header)s
    Fault %(class_name)s%(tpl_args)s::initiateAcc(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;
        unsigned eCount = RiscvStaticInst::getCurUveVecLen(
            xc->tcBase());

        %(op_decl)s;
        %(op_rd)s;
        %(ea_code)s;

        TheISA::VecRegContainer memData;
        auto memDataView = memData.as<MemElemType>();

        %(wren_code)s;

        if (fault == NoFault) {
            %(memacc_code)s;
        }

        if (fault == NoFault) {
            fault = xc->writeMem(memData.raw_ptr<uint8_t>(), memAccessSize, EA,
                this->memAccessFlags, NULL, wrEn);
        }

        return fault;
    }
}};

def template UveStoreCompleteAcc {{
    %(tpl_header)s
    Fault %(class_name)s%(tpl_args)s::completeAcc(PacketPtr pkt,
        ExecContext *xc, Trace::InstRecord *traceData) const
    {
        %(set_update_base_address)s;
        return NoFault;
    }
}};
