/////////////////////////////////
//
// Uve vector memory operations templates definition
// -----------------
// JoÃ£o Domingos
//

//JMNOTE: Load/Store Header Declaration Templates

def template UveVectorLoadDeclare {{
    %(tpl_header)s
    class %(class_name)s : public %(base_class)s
    {
      protected:
        typedef RegElemType TPElem;
        mutable int memAccessSize_persistent;
        mutable int eCount_persistent;

      public:
        %(class_name)s(const char* mnem, ExtMachInst machInst,
            uint8_t _VDest, uint8_t _RS1,
            uint8_t _RS2)
            : %(base_class)s(mnem, machInst, %(op_class)s,
                _VDest, _RS1, _RS2)
        {
            %(constructor)s;
        }

        Fault execute(ExecContext *, Trace::InstRecord *) const;
        Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;
        Fault completeAcc(PacketPtr, ExecContext *, Trace::InstRecord *) const;

    };
}};

def template UveVectorStoreDeclare {{
    %(tpl_header)s
    class %(class_name)s : public %(base_class)s
    {
      protected:
        typedef RegElemType TPElem;
        mutable int memAccessSize_persistent;
        mutable int eCount_persistent;

      public:
        %(class_name)s(const char* mnem, ExtMachInst machInst,
            uint8_t _VSrc1, uint8_t _RS1,
            uint8_t _RS2)
            : %(base_class)s(mnem, machInst, %(op_class)s,
                _VSrc1, _RS1, _RS2)
        {
            %(constructor)s;
        }

        Fault execute(ExecContext *, Trace::InstRecord *) const;
        Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;
        Fault completeAcc(PacketPtr, ExecContext *, Trace::InstRecord *) const;

    };
}};

//JMNOTE: Load/Store Template Implementation Templates


def template UveVectorMemExecDeclare {{
    template
    Fault %(class_name)s%(tpl_args)s::execute(ExecContext *,
        Trace::InstRecord *) const;

    template
    Fault %(class_name)s%(tpl_args)s::initiateAcc(ExecContext *,
        Trace::InstRecord *) const;

    template
    Fault %(class_name)s%(tpl_args)s::completeAcc(PacketPtr,
        ExecContext *, Trace::InstRecord *) const;
}};

//JMNOTE: Load Instruction Templates

def template UveVectorLoadExecute {{
    %(tpl_header)s
    Fault %(class_name)s%(tpl_args)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;
        unsigned eCount = 0;
        unsigned maxExecSize = RiscvStaticInst::getCurUveVecLen(
            xc->tcBase()) / sizeof(RegElemType);
        unsigned size = 0;
        int memAccessSize = 0;

        %(op_decl)s;
        %(op_rd)s;
        %(ea_code)s;

        if(size > maxExecSize){
            size = maxExecSize;
        }
        if(size > 0){
            eCount = size;
        }
        else {
            eCount = maxExecSize;
        }
        memAccessSize = eCount * sizeof(RegElemType);
        memAccessSize_persistent = memAccessSize;

        DPRINTF(UVEMem, "%(class_name)s->execute: eCount: %d | "
            "maxExecSize: %d\n", eCount, maxExecSize);

        DPRINTF(UVEMem, "%(class_name)s->execute: EA:%d | memAccSize:%d\n",
                EA, memAccessSize);

        TheISA::VecRegContainer memData;
        auto memDataView = memData.as<RegElemType>();

        fault = xc->readMem(EA, memData.raw_ptr<uint8_t>(), memAccessSize,
            this->memAccessFlags);

        if (fault == NoFault) {
            %(memacc_code)s;

            MEM_PRINTF(memDataView,">",Vd,eCount)

            %(set_update_base_address)s;
            %(op_wb)s;
        }

        return fault;
    }
}};

def template UveVectorLoadInitiateAcc {{
    %(tpl_header)s
    Fault %(class_name)s%(tpl_args)s::initiateAcc(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;
        unsigned eCount = 0;
        unsigned maxExecSize = RiscvStaticInst::getCurUveVecLen(
            xc->tcBase()) / sizeof(RegElemType);
        unsigned size = 0;
        int memAccessSize = 0;

        DPRINTF(UVEMem, "%(class_name)s->initiateAcc maxExecSize(%d)\n",
            maxExecSize);

        %(op_src_decl)s;
        %(op_rd)s;
        %(ea_code)s;

        if(size > maxExecSize){
            size = maxExecSize;
        }
        if(size > 0){
            eCount = size;
        }
        else {
            eCount = maxExecSize;
        }
        memAccessSize = eCount * sizeof(RegElemType);
        memAccessSize_persistent = memAccessSize;
        eCount_persistent = eCount;

        fault = xc->initiateMemRead(EA, memAccessSize, this->memAccessFlags);

        return fault;
    }
}};

def template UveVectorLoadCompleteAcc {{
    %(tpl_header)s
    Fault %(class_name)s%(tpl_args)s::completeAcc(PacketPtr pkt,
        ExecContext *xc, Trace::InstRecord *traceData) const
    {
        int eCount = eCount_persistent;
        auto memAccessSize = memAccessSize_persistent;
        %(op_decl)s;
        %(op_rd)s;

        TheISA::VecRegContainer memData;
        auto memDataView = memData.as<RegElemType>();

        memcpy(memData.raw_ptr<uint8_t>(), pkt->getPtr<uint8_t>(),
                pkt->getSize());

        DPRINTF(UVEMem, "%(class_name)s->completeAcc\n");

        %(memacc_code)s;
        MEM_PRINTF(memDataView,">",Vd,eCount);
        %(set_update_base_address)s;
        %(op_wb)s;

        return NoFault;
    }
}};

//JMNOTE: Store Instruction Templates

def template UveVectorStoreExecute {{
    %(tpl_header)s
    Fault %(class_name)s%(tpl_args)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;
        unsigned eCount = 0;
        unsigned size = 0;
        int memAccessSize = 0;

        %(op_decl)s;
        %(op_rd)s;

        uint8_t vector_width = tmp_s1.get_width();
        uint8_t vec_elem_bytes = 1 << vector_width;
        unsigned maxExecSize =
            RiscvStaticInst::getCurUveVecLen(xc->tcBase()) / vec_elem_bytes;
        uint8_t vector_valid_index = tmp_s1.get_valid();

        %(ea_code)s;

        DPRINTF(UVEMem, "%(class_name)s->execute: vector_width(%d) | "
            "maxExecSize(%d)\n", vector_width, maxExecSize);
        if(size > maxExecSize){
            size = maxExecSize;
        }
        if(size > 0){
            eCount = size * vec_elem_bytes;
        }
        else {
            eCount = maxExecSize * vec_elem_bytes;
        }
        if(eCount > vector_valid_index){
            eCount = vector_valid_index;
        }
        memAccessSize = eCount * vec_elem_bytes;
        memAccessSize_persistent = memAccessSize;

        DPRINTF(UVEMem, "%(class_name)s->execute: eCount: %d\n",
                eCount);

        DPRINTF(UVEMem, "%(class_name)s->execute: EA:%d | memAccSize:%d\n",
                EA, memAccessSize);

        TheISA::VecRegContainer memData;
        auto memDataView = memData.as<RegElemType>();

        if (fault == NoFault) {
            %(memacc_code)s;
            MEM_PRINTF(memDataView,"<",Vs1,eCount);
        }

        if (fault == NoFault) {
            fault = xc->writeMem(memData.raw_ptr<uint8_t>(), memAccessSize, EA,
                this->memAccessFlags, NULL);
        }

        if (fault == NoFault) {
            %(set_update_base_address)s;
            %(op_wb)s;
        }

        return fault;
    }
}};

def template UveVectorStoreInitiateAcc {{
    %(tpl_header)s
    Fault %(class_name)s%(tpl_args)s::initiateAcc(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;
        unsigned eCount = 0;
        unsigned size = 0;
        int memAccessSize = 0;

        %(op_decl)s;
        %(op_rd)s;

        uint8_t vector_width = tmp_s1.get_width();
        uint8_t vec_elem_bytes = 1 << vector_width;
        unsigned maxExecSize =
            RiscvStaticInst::getCurUveVecLen(xc->tcBase()) / vec_elem_bytes;
        uint8_t vector_valid_index = tmp_s1.get_valid();

        %(ea_code)s;

        DPRINTF(UVEMem, "%(class_name)s->initiateAcc: vector_width(%d) | "
            "maxExecSize(%d)\n", vector_width, maxExecSize);
        if(size > maxExecSize){
            size = maxExecSize;
        }
        if(size > 0){
            eCount = size * vec_elem_bytes;
        }
        else {
            eCount = maxExecSize * vec_elem_bytes;
        }
        if(eCount > vector_valid_index){
            eCount = vector_valid_index;
        }
        memAccessSize = eCount;
        memAccessSize_persistent = memAccessSize;

        DPRINTF(UVEMem, "%(class_name)s->initiateAcc: EA:%d | memAccSize:%d\n",
                EA, memAccessSize);

        TheISA::VecRegContainer memData;
        auto memDataView = memData.as<RegElemType>();

        if (fault == NoFault) {
            %(memacc_code)s;
            MEM_PRINTF(memDataView,"<",Vs1,eCount);
        }

        if (fault == NoFault) {
            fault = xc->writeMem(memData.raw_ptr<uint8_t>(), memAccessSize, EA,
                this->memAccessFlags, NULL);
        }

        if (fault == NoFault) {
            %(op_wb)s;
        }

        %(set_update_base_address)s;

        %(op_wb)s;

        return fault;
    }
}};

def template UveVectorStoreCompleteAcc {{
    %(tpl_header)s
    Fault %(class_name)s%(tpl_args)s::completeAcc(PacketPtr pkt,
        ExecContext *xc, Trace::InstRecord *traceData) const
    {
        DPRINTF(UVEMem, "%(class_name)s->completeAcc\n");
        return NoFault;
    }
}};

//JMNOTE: Uve Dup Header Declaration Template

def template UveVectorDupDeclare {{
    %(tpl_header)s
    class %(class_name)s : public %(base_class)s
    {
      protected:
        typedef RegElemType TPElem;

      public:
        %(class_name)s(const char* mnem, ExtMachInst machInst,
            uint8_t _VDest, uint8_t _RS1,
            uint8_t _PSrc2)
            : %(base_class)s(mnem, machInst, %(op_class)s,
                _VDest, _RS1, _PSrc2)
        {
            %(constructor)s;
        }

        Fault execute(ExecContext *, Trace::InstRecord *) const;
    };
}};

//JMNOTE: Generic Exec Declare Template Implementation Templates
//This expands templates, in order for the linkage process to work

def template UveVectorExecDeclare {{
    template
    Fault %(class_name)s%(tpl_args)s::execute(ExecContext *,
        Trace::InstRecord *) const;
}};

//JMNOTE: Dup Instruction Templates

def template UveVectorDupExecute {{
    %(tpl_header)s
    Fault %(class_name)s%(tpl_args)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        unsigned eCount = RiscvStaticInst::getCurUveVecLen(
            xc->tcBase()) / sizeof(RegElemType);

        %(op_decl)s;
        %(op_rd)s;

        DPRINTF(UVEMem, "%(class_name)s->execute: eCount: %d\n",
            eCount);
        DPRINTF(UVEMem, "%(class_name)s->execute: RS1: %d\n",
            Rs1);
        if (fault == NoFault) {
            %(ex_code)s;
            DPRINTF(UVEMem, "%(class_name)s->execute: Vd: %s\n",
            Vd.print());

            tmp_d0.set_width(width_converter<RegElemType>::width);
            tmp_d0.set_valid(eCount * sizeof(RegElemType));
            %(op_wb)s;
        }

        return fault;
    }
}};


//JMNOTE: Uve Move Header Declaration Template

def template UveVectorMoveDeclare {{
    %(tpl_header)s
    class %(class_name)s : public %(base_class)s
    {
      protected:
        typedef RegElemType TPElem;

      public:
        %(class_name)s(const char* mnem, ExtMachInst machInst,
            uint8_t _VDest, uint8_t _VSrc1,
            uint8_t _PSrc2)
            : %(base_class)s(mnem, machInst, %(op_class)s,
                _VDest, _VSrc1, _PSrc2)
        {
            %(constructor)s;
        }

        Fault execute(ExecContext *, Trace::InstRecord *) const;
    };
}};

//JMNOTE: Move Instruction Templates

def template UveVectorMoveExecute {{
    %(tpl_header)s
    Fault %(class_name)s%(tpl_args)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {

        //JMTODO: Implement valid index
        Fault fault = NoFault;
        unsigned eCount =
            RiscvStaticInst::getCurUveVecLen(xc->tcBase())
            / sizeof(RegElemType);

        %(op_decl)s;
        %(op_rd)s;

        DPRINTF(UVEMem, "%(class_name)s->execute: eCount: %d D[%d] S[%d]\n",
            eCount, VDest, VSrc1);
        if (fault == NoFault) {
            %(ex_code)s;
            DPRINTF(UVEMem, "%(class_name)s->execute: Vd: %s\n", Vd.print());
            %(op_wb)s;
        }

        return fault;
    }
}};


//JMNOTE: Uve Move Vector to Scalar Header Declaration Template

def template UveVectorMoveVSDeclare {{
    %(tpl_header)s
    class %(class_name)s : public %(base_class)s
    {
      protected:
        typedef RegElemType TPElem;

      public:
        %(class_name)s(const char* mnem, ExtMachInst machInst,
            uint8_t _RD, uint8_t _VSrc1,
            uint8_t _PSrc2)
            : %(base_class)s(mnem, machInst, %(op_class)s,
                _RD, _VSrc1, _PSrc2)
        {
            %(constructor)s;
        }

        Fault execute(ExecContext *, Trace::InstRecord *) const;
    };
}};

//JMNOTE: Move Vector to Scalar Instruction Templates

def template UveVectorMoveVSExecute {{
    %(tpl_header)s
    Fault %(class_name)s%(tpl_args)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        %(op_decl)s;
        %(op_rd)s;
        uint8_t vector_width = tmp_s0.get_width();

        if (fault == NoFault) {
            DPRINTF(UVEMem, "%(class_name)s->execute: before Rd: %s\n",
            Rd);
            DPRINTF(UVEMem, "%(class_name)s->execute: Vect Width: %d\n",
            vector_width);
            %(ex_code)s;
            DPRINTF(UVEMem, "%(class_name)s->execute: Rd: %s\n",
            Rd);
            %(op_wb)s;
        }

        return fault;
    }
}};



//JMNOTE: Uve Conversion Vector Header Declaration Template

def template UveVectorConvDeclare {{
    %(tpl_header)s
    class %(class_name)s : public %(base_class)s
    {
      protected:
        typedef RegElemType TPElem;

      public:
        %(class_name)s(const char* mnem, ExtMachInst machInst,
            uint8_t _VDest, uint8_t _VSrc1)
            : %(base_class)s(mnem, machInst, %(op_class)s,
                _VDest, _VSrc1)
        {
            %(constructor)s;
        }

        Fault execute(ExecContext *, Trace::InstRecord *) const;
    };
}};

//JMNOTE: Conversion Vector Instruction Templates

def template UveVectorConvExecute {{
    %(tpl_header)s
    Fault %(class_name)s%(tpl_args)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint8_t dest_vector_width = width_converter<RegElemType>::width;
        unsigned dest_eCount =
            RiscvStaticInst::getCurUveVecLen(xc->tcBase()) /
                (1 << dest_vector_width);


        %(op_decl)s;
        %(op_rd)s;


        uint8_t src_vector_width = tmp_s0.get_width();
        unsigned src_eCount =
            RiscvStaticInst::getCurUveVecLen(xc->tcBase()) /
                (1 << src_vector_width);

        DPRINTF(UVEMem, "%(class_name)s->execute: Src_W(%d) Dest_W(%d)\n",
            src_vector_width, dest_vector_width);
        DPRINTF(UVEMem, "%(class_name)s->execute: Src_eC(%d) Dest_eC(%d)\n",
            src_eCount, dest_eCount);

        if (fault == NoFault) {
            %(ex_code)s;

            RiscvStaticInst::setUveVecType(xc->tcBase(), VDest,
                dest_vector_width);
            tmp_d0.set_width(src_vector_width);
            tmp_d0.set_valid(tmp_s0.get_valid());

            %(op_wb)s;
        }

        return fault;
    }
}};