/////////////////////////////////
//
// Uve vector memory operations templates definition
// -----------------
// JoÃ£o Domingos
//

//JMNOTE: Load/Store Header Declaration Templates

def template UveMemLoadDeclare {{
    %(tpl_header)s
    class %(class_name)s : public %(base_class)s
    {
      protected:
        typedef RegElemType TPElem;
        int memAccessSize_persistent;
        int eCount_persistent;

      public:
        %(class_name)s(const char* mnem, ExtMachInst machInst,
            uint8_t _VDest, uint8_t _RS1,
            uint8_t _RS2)
            : %(base_class)s(mnem, machInst, %(op_class)s,
                _VDest, _RS1, _RS2)
        {
            %(constructor)s;
        }

        Fault execute(ExecContext *, Trace::InstRecord *) const;
        Fault initiateAcc(ExecContext *, Trace::InstRecord *);
        Fault completeAcc(PacketPtr, ExecContext *, Trace::InstRecord *) const;

    };
}};

def template UveMemStoreDeclare {{
    %(tpl_header)s
    class %(class_name)s : public %(base_class)s
    {
      protected:
        typedef RegElemType TPElem;
        int memAccessSize_persistent;
        int eCount_persistent;

      public:
        %(class_name)s(const char* mnem, ExtMachInst machInst,
            uint8_t _VSrc1, uint8_t _RS1,
            uint8_t _RS2)
            : %(base_class)s(mnem, machInst, %(op_class)s,
                _VSrc1, _RS1, _RS2)
        {
            %(constructor)s;
        }

        Fault execute(ExecContext *, Trace::InstRecord *) const;
        Fault initiateAcc(ExecContext *, Trace::InstRecord *);
        Fault completeAcc(PacketPtr, ExecContext *, Trace::InstRecord *) const;

    };
}};

//JMNOTE: Load/Store Template Implementation Templates


def template UveMemExecDeclare {{
    template
    Fault %(class_name)s%(tpl_args)s::execute(ExecContext *,
        Trace::InstRecord *) const;

    template
    Fault %(class_name)s%(tpl_args)s::initiateAcc(ExecContext *,
        Trace::InstRecord *);

    template
    Fault %(class_name)s%(tpl_args)s::completeAcc(PacketPtr,
        ExecContext *, Trace::InstRecord *) const;
}};

//JMNOTE: Load Instruction Templates

def template UveLoadExecute {{
    %(tpl_header)s
    Fault %(class_name)s%(tpl_args)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;
        unsigned eCount = 0;
        unsigned maxExecSize = RiscvStaticInst::getCurUveVecLen(
            xc->tcBase()) / sizeof(RegElemType);
        unsigned size = 0;
        int memAccessSize = 0;

        %(op_decl)s;
        %(op_rd)s;
        %(ea_code)s;

        if(size > maxExecSize){
            size = maxExecSize;
        }
        if(size > 0){
            eCount = size;
            memAccessSize = size * sizeof(RegElemType);
        }
        else {
            eCount = maxExecSize;
            memAccessSize = maxExecSize * sizeof(RegElemType);
        }

        DPRINTF(UVEMem, "%(class_name)s->execute: eCount: %d | "
            "maxExecSize: %d\n", eCount, maxExecSize);

        DPRINTF(UVEMem, "%(class_name)s->execute: EA:%d | memAccSize:%d\n",
                EA, memAccessSize);

        TheISA::VecRegContainer memData;
        auto memDataView = memData.as<RegElemType>();

        fault = xc->readMem(EA, memData.raw_ptr<uint8_t>(), memAccessSize,
            this->memAccessFlags);

        if (fault == NoFault) {
            %(memacc_code)s;

            DPRINTF(UVEMem, "________________________________\n");
            for (int i = 0; i < eCount; i++) {
                DPRINTF(UVEMem, "i(%d) M(%d)>V(%d)\n",
                    i, memDataView[i], Vd[i]);
            }
            DPRINTF(UVEMem, "________________________________\n");

            RiscvStaticInst::setUveVecType(xc->tcBase(), VDest,
                width_converter<RegElemType>::width);

            %(set_update_base_address)s;
            %(op_wb)s;
        }

        return fault;
    }
}};

def template UveLoadInitiateAcc {{
    %(tpl_header)s
    Fault %(class_name)s%(tpl_args)s::initiateAcc(ExecContext *xc,
        Trace::InstRecord *traceData)
    {
        Addr EA;
        Fault fault = NoFault;
        unsigned eCount = 0;
        unsigned maxExecSize = RiscvStaticInst::getCurUveVecLen(
            xc->tcBase()) / sizeof(RegElemType);
        unsigned size = 0;
        int memAccessSize = 0;

        %(op_src_decl)s;
        %(op_rd)s;
        %(ea_code)s;

        if(size > maxExecSize){
            size = maxExecSize;
        }
        if(size > 0){
            eCount = size;
            memAccessSize = size * sizeof(RegElemType);
        }
        else {
            eCount = maxExecSize;
            memAccessSize = maxExecSize * sizeof(RegElemType);
        }

        eCount_persistent = eCount;
        memAccessSize_persistent = memAccessSize;

        fault = xc->initiateMemRead(EA, memAccessSize, this->memAccessFlags);

        return fault;
    }
}};

def template UveLoadCompleteAcc {{
    %(tpl_header)s
    Fault %(class_name)s%(tpl_args)s::completeAcc(PacketPtr pkt,
        ExecContext *xc, Trace::InstRecord *traceData) const
    {
        int eCount = eCount_persistent;
        %(op_decl)s;
        %(op_rd)s;

        TheISA::VecRegContainer memData;
        auto memDataView = memData.as<RegElemType>();

        memcpy(memData.raw_ptr<uint8_t>(), pkt->getPtr<uint8_t>(),
                pkt->getSize());

        %(memacc_code)s;
        %(set_update_base_address)s;
        %(op_wb)s;

        return NoFault;
    }
}};

//JMNOTE: Store Instruction Templates

def template UveStoreExecute {{
    %(tpl_header)s
    Fault %(class_name)s%(tpl_args)s::execute(ExecContext *xc,
        Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;
        unsigned eCount = 0;
        uint8_t vector_width = RiscvStaticInst::getUveVecType(xc->tcBase(),
            VSrc1);
        uint8_t vec_elem_bytes = 1 << vector_width;
        unsigned maxExecSize = RiscvStaticInst::getCurUveVecLen(
            xc->tcBase()) / vec_elem_bytes;
        unsigned size = 0;
        int memAccessSize = 0;
        DPRINTF(UVEMem, "%(class_name)s->execute: vector_width(%d) | "
            "maxExecSize(%d)\n", vector_width, maxExecSize);

        %(op_decl)s;
        %(op_rd)s;
        %(ea_code)s;

        if(size > maxExecSize){
            size = maxExecSize;
        }
        if(size > 0){
            eCount = size * vec_elem_bytes;
            memAccessSize = size * vec_elem_bytes;
        }
        else {
            eCount = maxExecSize * vec_elem_bytes;
            memAccessSize = maxExecSize * vec_elem_bytes;
        }

        DPRINTF(UVEMem, "%(class_name)s->execute: eCount: %d\n",
                eCount);

        DPRINTF(UVEMem, "%(class_name)s->execute: EA:%d | memAccSize:%d\n",
                EA, memAccessSize);

        TheISA::VecRegContainer memData;
        auto memDataView = memData.as<RegElemType>();

        if (fault == NoFault) {
            %(memacc_code)s;

            DPRINTF(UVEMem, "________________________________\n");
            for (int i = 0; i < eCount; i++) {
                DPRINTF(UVEMem, "i(%d) M(%d)<V(%d)\n",
                    i, memDataView[i], Vs1[i]);
            }
            DPRINTF(UVEMem, "________________________________\n");
        }

        if (fault == NoFault) {
            fault = xc->writeMem(memData.raw_ptr<uint8_t>(), memAccessSize, EA,
                this->memAccessFlags, NULL);
        }

        if (fault == NoFault) {
            %(set_update_base_address)s;
            %(op_wb)s;
        }

        return fault;
    }
}};

def template UveStoreInitiateAcc {{
    %(tpl_header)s
    Fault %(class_name)s%(tpl_args)s::initiateAcc(ExecContext *xc,
        Trace::InstRecord *traceData)
    {
        Addr EA;
        Fault fault = NoFault;
        unsigned eCount = 0;
        uint8_t vector_width = RiscvStaticInst::getUveVecType(xc->tcBase(),
            VSrc1);
        uint8_t vec_elem_bytes = 1 << vector_width;
        unsigned maxExecSize = RiscvStaticInst::getCurUveVecLen(
            xc->tcBase()) / vec_elem_bytes;
        unsigned size = 0;
        int memAccessSize = 0;
        DPRINTF(UVEMem, "%(class_name)s->execute: vector_width(%d) | "
            "maxExecSize(%d)\n", vector_width, maxExecSize);

        %(op_decl)s;
        %(op_rd)s;
        %(ea_code)s;

        if(size > maxExecSize){
            size = maxExecSize;
        }
        if(size > 0){
            eCount = size * vec_elem_bytes;
            memAccessSize = size * vec_elem_bytes;
        }
        else {
            eCount = maxExecSize * vec_elem_bytes;
            memAccessSize = maxExecSize * vec_elem_bytes;
        }

        TheISA::VecRegContainer memData;
        auto memDataView = memData.as<RegElemType>();

        if (fault == NoFault) {
            %(memacc_code)s;
        }

        if (fault == NoFault) {
            fault = xc->writeMem(memData.raw_ptr<uint8_t>(), memAccessSize, EA,
                this->memAccessFlags, NULL);
        }

        if (fault == NoFault) {
            %(op_wb)s;
        }

        return fault;
    }
}};

def template UveStoreCompleteAcc {{
    %(tpl_header)s
    Fault %(class_name)s%(tpl_args)s::completeAcc(PacketPtr pkt,
        ExecContext *xc, Trace::InstRecord *traceData) const
    {
        %(op_decl)s;
        %(op_rd)s;

        %(set_update_base_address)s;

        %(op_wb)s;
        return NoFault;
    }
}};
