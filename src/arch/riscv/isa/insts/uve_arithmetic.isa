/////////////////////////////////
//
// Uve vector arithmetic operations instructions definition
// -----------------
// Jo√£o Domingos
//

output header {{

    template <class BaseU, class BaseS, class BaseFP>
    StaticInstPtr
    decodeThreeVecPredicatedFPTemplated(const char * mn, uint8_t signed_fp,
                                ExtMachInst machInst,
                                uint8_t rd,
                                uint8_t rs1,
                                uint8_t rs2,
                                uint8_t ps3)
    {
        switch (signed_fp) {
            case 0x0: // Unsigned
                return new BaseU(mn, machInst, rd, rs1, rs2, ps3);
                break;
            case 0x2: // Signed
                return new BaseS(mn, machInst, rd, rs1, rs2, ps3);
                break;
            default: // Floating Point
                return new BaseFP(mn, machInst, rd, rs1, rs2, ps3);
                break;
        }
    }

    template <class BaseU, class BaseS, class BaseFP>
    StaticInstPtr
    decodeTwoVecPredicatedFPTemplated(const char * mn, uint8_t signed_fp,
                                ExtMachInst machInst,
                                uint8_t rd,
                                uint8_t rs1,
                                uint8_t ps3)
    {
        switch (signed_fp) {
            case 0x0: // Unsigned
                return new BaseU(mn, machInst, rd, rs1, ps3);
                break;
            case 0x2: // Signed
                return new BaseS(mn, machInst, rd, rs1, ps3);
                break;
            default: // Floating Point
                return new BaseFP(mn, machInst, rd, rs1, ps3);
                break;
        }
    }

    template <class BaseS, class BaseFP>
    StaticInstPtr
    decodeTwoVecPredicatedFPoTemplated(const char * mn, uint8_t signed_fp,
                                ExtMachInst machInst,
                                uint8_t rd,
                                uint8_t rs1,
                                uint8_t ps3)
    {
        switch (signed_fp & 0b01) {
            case 0x1: // Floating Point
                return new BaseFP(mn, machInst, rd, rs1, ps3);
                break;
            default: // Signed
                return new BaseS(mn, machInst, rd, rs1, ps3);
                break;
        }
    }
}};

let {{
    header_output = ''
    exec_output = ''
    decoders = { 'Generic': {} }

    TypeUnsigned = {
        'type8': 'uint8_t',
        'type16': 'uint16_t',
        'type32': 'uint32_t',
        'type64': 'uint64_t'
    }
    TypeSigned = {
        'type8': 'int8_t',
        'type16': 'int16_t',
        'type32': 'int32_t',
        'type64': 'int64_t'
    }

    TypeFP = {
        'type8': 'uint8_t',
        'type16': 'uint16_t',
        'type32': 'float',
        'type64': 'double'
    }

    def emitUveArithThreeVecPredicatedFPInsts(mnemonic, class_name,
                                    code = None, generic_code = None,
                                    generic_code_float = None,
                                    generic_code_signed = None,
                                    dest_as_source = False):
        global header_output, exec_output, decoders

        genericArithThreeVecPredicated = '''
        auto src1_vc = (TheISA::VecRegContainer)Vs1_x;
        auto src2_vc = (TheISA::VecRegContainer)Vs2_x;
        %(inst)s;
        TheISA::VecRegContainer output;
        switch(src1_vw){
            case 0:{
                auto v1 = src1_vc.as<%(type8)s>();
                auto v2 = src2_vc.as<%(type8)s>();
                auto out = output.as<%(type8)s>();
                %(cast8)s;
                for(int i=0;i<iCount;i++){
                   %(generic_op)s
                }
            }
            break;
            case 1:{
                auto v1 = src1_vc.as<%(type16)s>();
                auto v2 = src2_vc.as<%(type16)s>();
                auto out = output.as<%(type16)s>();
                %(cast16)s;
                for(int i=0;i<iCount;i++){
                   %(generic_op)s
                }
            }
            break;
            case 2: {
                auto v1 = src1_vc.as<%(type32)s>();
                auto v2 = src2_vc.as<%(type32)s>();
                auto out = output.as<%(type32)s>();
                %(cast32)s;
                for(int i=0;i<iCount;i++){
                   %(generic_op)s
                }
            }
            break;
            default:
            {
                auto v1 = src1_vc.as<%(type64)s>();
                auto v2 = src2_vc.as<%(type64)s>();
                auto out = output.as<%(type64)s>();
                %(cast64)s;
                for(int i=0;i<iCount;i++){
                   %(generic_op)s
                }
            }
            break;
        }

        auto out = output.as<uint8_t>();
        for(int i=0;i<eCount;i++)
            Vd_x[i] = out[i];
        '''

        generic_fixed_code = "out[i] = v1[i] %(op)s v2[i];"

        dest_ops = {
            "inst": "auto dest_vc = (TheISA::VecRegContainer)Vd_merge_x;",
            "cast8":  "auto v3 = dest_vc.as<%(type8)s>();",
            "cast16":  "auto v3 = dest_vc.as<%(type16)s>();",
            "cast32":  "auto v3 = dest_vc.as<%(type32)s>();",
            "cast64":  "auto v3 = dest_vc.as<%(type64)s>();"
        } if dest_as_source else {"inst": "",
            "cast8":"","cast16":"","cast32":"","cast64":""}


        type_suffixes = ["Unsigned", "Signed", "FP"]

        if code is not None:
            fixed_code = generic_fixed_code % {"op":code}

        for idx, suffix in enumerate(type_suffixes):
            full_class_name = class_name + suffix
            code_dict = eval("Type" + suffix)

            dest_op = {}
            for key, val in dest_ops.items():
               dest_op[key] = val % code_dict

            if generic_code is not None:
                if suffix == "FP" and generic_code_float is not None:
                    aux_gen = generic_code_float
                elif suffix == "Signed" and generic_code_signed is not None:
                    aux_gen = generic_code_signed
                else:
                    aux_gen = generic_code
                code_dict.update({"generic_op":aux_gen})
            else:
                code_dict.update({"generic_op":fixed_code})
            code_dict.update(dest_op)
            full_code = genericArithThreeVecPredicated % code_dict

            Iop = InstObjParams(mnemonic,
                full_class_name,
                'UveBaseThreeVecPredicated',
                {'ex_code' : full_code,
                'op_class': 'SimdAluOp'},
                [])

            header_output += UveThreeVecPredicatedDeclare.subst(Iop)
            exec_output += UveThreeVecPredicatedExecute.subst(Iop)
            exec_output += UveArithExecDeclare.subst(Iop)


    emitUveArithThreeVecPredicatedFPInsts("so.a.add", "UveArithAdd", "+")
    emitUveArithThreeVecPredicatedFPInsts("so.a.sub", "UveArithSub", "-")
    emitUveArithThreeVecPredicatedFPInsts("so.a.mul", "UveArithMul", "*")
    emitUveArithThreeVecPredicatedFPInsts("so.a.div", "UveArithDiv",
        generic_code='''
        if (v2[i] == 0) {
            out[i] = numeric_limits<uint64_t>::max();
        } else {
            out[i] = v1[i]/v2[i];
        }
        ''',
        generic_code_float= '''
        if (std::isnan(v1[i]) || std::isnan(v2[i])) {
            out[i] = numeric_limits<double>::quiet_NaN();
        } else {
            out[i] = (float)((double)v1[i]/(double)v2[i]);
        }
        ''',
        generic_code_signed='''
         if (v2[i] == 0) {
            out[i] = -1;
        } else if (v1[i] == numeric_limits<int64_t>::min()
                && v2[i] == -1) {
            out[i] = numeric_limits<int64_t>::min();
        } else {
            out[i] = v1[i]/v2[i];
        }
        ''')
    emitUveArithThreeVecPredicatedFPInsts("so.a.mac", "UveArithMac",
        generic_code="out[i]=v3[i] + (v1[i]*v2[i]);", dest_as_source=True)


    def emitUveArithTwoVecPredicatedFPoInsts(mnemonic, class_name,
                                    code = None,
                                    generic_code_float = None,
                                    generic_code_signed = None):
        global header_output, exec_output, decoders

        genericArithTwoVecPredicated = '''
        auto src1_vc = (TheISA::VecRegContainer)Vs1_x;
        TheISA::VecRegContainer output;
        switch(src1_vw){
            case 0:{
                auto v1 = src1_vc.as<%(type8)s>();
                auto out = output.as<%(type8)s>();
                for(int i=0;i<iCount;i++){
                   %(generic_op)s
                }
            }
            break;
            case 1:{
                auto v1 = src1_vc.as<%(type16)s>();
                auto out = output.as<%(type16)s>();
                for(int i=0;i<iCount;i++){
                   %(generic_op)s
                }
            }
            break;
            case 2: {
                auto v1 = src1_vc.as<%(type32)s>();
                auto out = output.as<%(type32)s>();
                for(int i=0;i<iCount;i++){
                   %(generic_op)s
                }
            }
            break;
            default:
            {
                auto v1 = src1_vc.as<%(type64)s>();
                auto out = output.as<%(type64)s>();
                for(int i=0;i<iCount;i++){
                   %(generic_op)s
                }
            }
            break;
        }

        auto out = output.as<uint8_t>();
        for(int i=0;i<eCount;i++)
            Vd_x[i] = out[i];
        '''

        generic_fixed_code = "out[i] = %(op)s(v1[i]);"


        type_suffixes = ["Signed", "FP"]

        if code is not None:
            fixed_code = generic_fixed_code % {"op":code}

        for idx, suffix in enumerate(type_suffixes):
            full_class_name = class_name + suffix
            code_dict = eval("Type" + suffix)
            if code is None:
                if suffix == "FP" and generic_code_float is not None:
                    aux_gen = generic_code_float
                elif suffix == "Signed" and generic_code_signed is not None:
                    aux_gen = generic_code_signed

                code_dict.update({"generic_op":aux_gen})
            else:
                code_dict.update({"generic_op":fixed_code})

            full_code = genericArithTwoVecPredicated % code_dict

            Iop = InstObjParams(mnemonic,
                full_class_name,
                'UveBaseTwoVecPredicated',
                {'ex_code' : full_code,
                'op_class': 'SimdAluOp'},
                [])

            header_output += UveTwoVecPredicatedDeclare.subst(Iop)
            exec_output += UveTwoVecPredicatedExecute.subst(Iop)
            exec_output += UveArithExecDeclare.subst(Iop)


    emitUveArithTwoVecPredicatedFPoInsts("so.a.abs", "UveArithAbs", "uveAbs")

}};