/////////////////////////////////
//
// Uve vector arithmetic operations instructions definition
// -----------------
// Jo√£o Domingos
//

output header {{

    template <class BaseU, class BaseS, class BaseFP>
    StaticInstPtr
    decodeThreeVecPredicatedFPTemplated(const char * mn, uint8_t signed_fp,
                                ExtMachInst machInst,
                                uint8_t rd,
                                uint8_t rs1,
                                uint8_t rs2,
                                uint8_t ps3)
    {
        switch (signed_fp) {
            case 0x0: // Unsigned
                return new BaseU(mn, machInst, rd, rs1, rs2, ps3);
                break;
            case 0x2: // Signed
                return new BaseS(mn, machInst, rd, rs1, rs2, ps3);
                break;
            default: // Floating Point
                return new BaseFP(mn, machInst, rd, rs1, rs2, ps3);
                break;
        }
    }

    template <class BaseU, class BaseS, class BaseFP>
    StaticInstPtr
    decodeTwoVecPredicatedFPTemplated(const char * mn, uint8_t signed_fp,
                                ExtMachInst machInst,
                                uint8_t rd,
                                uint8_t rs1,
                                uint8_t ps3)
    {
        switch (signed_fp) {
            case 0x0: // Unsigned
                return new BaseU(mn, machInst, rd, rs1, ps3);
                break;
            case 0x2: // Signed
                return new BaseS(mn, machInst, rd, rs1, ps3);
                break;
            default: // Floating Point
                return new BaseFP(mn, machInst, rd, rs1, ps3);
                break;
        }
    }

    template <class BaseS, class BaseFP>
    StaticInstPtr
    decodeTwoVecPredicatedFPoTemplated(const char * mn, uint8_t signed_fp,
                                ExtMachInst machInst,
                                uint8_t rd,
                                uint8_t rs1,
                                uint8_t ps3)
    {
        switch (signed_fp & 0b01) {
            case 0x1: // Floating Point
                return new BaseFP(mn, machInst, rd, rs1, ps3);
                break;
            default: // Signed
                return new BaseS(mn, machInst, rd, rs1, ps3);
                break;
        }
    }
}};

let {{
    header_output = ''
    exec_output = ''
    decoders = { 'Generic': {} }

    TypeUnsigned = {
        'type8': 'uint8_t',
        'type16': 'uint16_t',
        'type32': 'uint32_t',
        'type64': 'uint64_t',
        'acc_type': 'uint64_t'
    }
    TypeSigned = {
        'type8': 'int8_t',
        'type16': 'int16_t',
        'type32': 'int32_t',
        'type64': 'int64_t',
        'acc_type': 'int64_t'
    }
    TypeFP = {
        'type8': 'uint8_t',
        'type16': 'uint16_t',
        'type32': 'float',
        'type64': 'double',
        'acc_type': 'double'
    }


    # JMNOTE: 3VecPredicatedFPInsts
    def emitUveArithThreeVecPredicatedFPInsts(mnemonic, class_name,
                                    code = None, generic_code = None,
                                    generic_code_float = None,
                                    generic_code_signed = None,
                                    dest_as_source = False):
        global header_output, exec_output, decoders

        genericArithThreeVecPredicated = '''
        auto src1_vc = (TheISA::VecRegContainer)Vs1_x;
        auto src2_vc = (TheISA::VecRegContainer)Vs2_x;
        %(inst)s;
        TheISA::VecRegContainer output;
        switch(src1_vw){
            case 0:{
                auto v1 = src1_vc.as<%(type8)s>();
                auto v2 = src2_vc.as<%(type8)s>();
                auto out = output.as<%(type8)s>();
                %(cast8)s;
                for(int i=0;i<iCount;i++){
                   %(generic_op)s
                }
            }
            break;
            case 1:{
                auto v1 = src1_vc.as<%(type16)s>();
                auto v2 = src2_vc.as<%(type16)s>();
                auto out = output.as<%(type16)s>();
                %(cast16)s;
                for(int i=0;i<iCount;i++){
                   %(generic_op)s
                }
            }
            break;
            case 2: {
                auto v1 = src1_vc.as<%(type32)s>();
                auto v2 = src2_vc.as<%(type32)s>();
                auto out = output.as<%(type32)s>();
                %(cast32)s;
                for(int i=0;i<iCount;i++){
                   %(generic_op)s
                }
            }
            break;
            default:
            {
                auto v1 = src1_vc.as<%(type64)s>();
                auto v2 = src2_vc.as<%(type64)s>();
                auto out = output.as<%(type64)s>();
                %(cast64)s;
                for(int i=0;i<iCount;i++){
                   %(generic_op)s
                }
            }
            break;
        }

        auto out = output.as<uint8_t>();
        for(int i=0;i<eCount;i++)
            Vd_x[i] = out[i];
        '''

        generic_fixed_code = "out[i] = v1[i] %(op)s v2[i];"

        dest_ops = {
            "inst": "auto dest_vc = (TheISA::VecRegContainer)Vd_merge_x;",
            "cast8":  "auto v3 = dest_vc.as<%(type8)s>();",
            "cast16":  "auto v3 = dest_vc.as<%(type16)s>();",
            "cast32":  "auto v3 = dest_vc.as<%(type32)s>();",
            "cast64":  "auto v3 = dest_vc.as<%(type64)s>();"
        } if dest_as_source else {"inst": "",
            "cast8":"","cast16":"","cast32":"","cast64":""}


        type_suffixes = ["Unsigned", "Signed", "FP"]

        if code is not None:
            fixed_code = generic_fixed_code % {"op":code}

        for idx, suffix in enumerate(type_suffixes):
            full_class_name = class_name + suffix
            code_dict = eval("Type" + suffix)

            dest_op = {}
            for key, val in dest_ops.items():
               dest_op[key] = val % code_dict

            if generic_code is not None:
                if suffix == "FP" and generic_code_float is not None:
                    aux_gen = generic_code_float
                elif suffix == "Signed" and generic_code_signed is not None:
                    aux_gen = generic_code_signed
                else:
                    aux_gen = generic_code
                code_dict.update({"generic_op":aux_gen})
            else:
                code_dict.update({"generic_op":fixed_code})
            code_dict.update(dest_op)
            full_code = genericArithThreeVecPredicated % code_dict

            Iop = InstObjParams(mnemonic,
                full_class_name,
                'UveBaseThreeVecPredicated',
                {'ex_code' : full_code,
                'op_class': 'SimdAluOp'},
                [])

            header_output += UveThreeVecPredicatedDeclare.subst(Iop)
            exec_output += UveThreeVecPredicatedExecute.subst(Iop)
            exec_output += UveArithExecDeclare.subst(Iop)

    # JMNOTE: 2VecPredicatedFPInsts (inc, dec)
    def emitUveArithTwoVecPredicatedFPInsts(mnemonic, class_name,
                                    code = None,
                                    generic_code_float = None,
                                    generic_code_signed = None):
        global header_output, exec_output, decoders

        genericArithTwoVecPredicated = '''
        auto src1_vc = (TheISA::VecRegContainer)Vs1_x;
        TheISA::VecRegContainer output;
        switch(src1_vw){
            case 0:{
                auto v1 = src1_vc.as<%(type8)s>();
                auto out = output.as<%(type8)s>();
                for(int i=0;i<iCount;i++){
                   %(generic_op)s
                }
            }
            break;
            case 1:{
                auto v1 = src1_vc.as<%(type16)s>();
                auto out = output.as<%(type16)s>();
                for(int i=0;i<iCount;i++){
                   %(generic_op)s
                }
            }
            break;
            case 2: {
                auto v1 = src1_vc.as<%(type32)s>();
                auto out = output.as<%(type32)s>();
                for(int i=0;i<iCount;i++){
                   %(generic_op)s
                }
            }
            break;
            default:
            {
                auto v1 = src1_vc.as<%(type64)s>();
                auto out = output.as<%(type64)s>();
                for(int i=0;i<iCount;i++){
                   %(generic_op)s
                }
            }
            break;
        }

        auto out = output.as<uint8_t>();
        for(int i=0;i<eCount;i++)
            Vd_x[i] = out[i];
        '''

        generic_fixed_code = "out[i] = %(op)s(v1[i]);"


        type_suffixes = ["Unsigned", "Signed", "FP"]

        if code is not None:
            fixed_code = generic_fixed_code % {"op":code}

        for idx, suffix in enumerate(type_suffixes):
            full_class_name = class_name + suffix
            code_dict = eval("Type" + suffix)
            if code is None:
                if suffix == "FP" and generic_code_float is not None:
                    aux_gen = generic_code_float
                elif suffix == "Signed" and generic_code_signed is not None:
                    aux_gen = generic_code_signed
                else:
                    aux_gen = generic_code
                code_dict.update({"generic_op":aux_gen})
            else:
                code_dict.update({"generic_op":fixed_code})

            full_code = genericArithTwoVecPredicated % code_dict

            Iop = InstObjParams(mnemonic,
                full_class_name,
                'UveBaseTwoVecPredicated',
                {'ex_code' : full_code,
                'op_class': 'SimdAluOp'},
                [])

            header_output += UveTwoVecPredicatedDeclare.subst(Iop)
            exec_output += UveTwoVecPredicatedExecute.subst(Iop)
            exec_output += UveArithExecDeclare.subst(Iop)

    # JMNOTE: 2VecPredicatedFPoInsts FPonly -> No unsigned code (abs, mod)
    def emitUveArithTwoVecPredicatedFPoInsts(mnemonic, class_name,
                                    code = None,
                                    generic_code_float = None,
                                    generic_code_signed = None):
        global header_output, exec_output, decoders

        genericArithTwoVecPredicated = '''
        auto src1_vc = (TheISA::VecRegContainer)Vs1_x;
        TheISA::VecRegContainer output;
        switch(src1_vw){
            case 0:{
                auto v1 = src1_vc.as<%(type8)s>();
                auto out = output.as<%(type8)s>();
                for(int i=0;i<iCount;i++){
                   %(generic_op)s
                }
            }
            break;
            case 1:{
                auto v1 = src1_vc.as<%(type16)s>();
                auto out = output.as<%(type16)s>();
                for(int i=0;i<iCount;i++){
                   %(generic_op)s
                }
            }
            break;
            case 2: {
                auto v1 = src1_vc.as<%(type32)s>();
                auto out = output.as<%(type32)s>();
                for(int i=0;i<iCount;i++){
                   %(generic_op)s
                }
            }
            break;
            default:
            {
                auto v1 = src1_vc.as<%(type64)s>();
                auto out = output.as<%(type64)s>();
                for(int i=0;i<iCount;i++){
                   %(generic_op)s
                }
            }
            break;
        }

        auto out = output.as<uint8_t>();
        for(int i=0;i<eCount;i++)
            Vd_x[i] = out[i];
        '''

        generic_fixed_code = "out[i] = %(op)s(v1[i]);"


        type_suffixes = ["Signed", "FP"]

        if code is not None:
            fixed_code = generic_fixed_code % {"op":code}

        for idx, suffix in enumerate(type_suffixes):
            full_class_name = class_name + suffix
            code_dict = eval("Type" + suffix)
            if code is None:
                if suffix == "FP" and generic_code_float is not None:
                    aux_gen = generic_code_float
                elif suffix == "Signed" and generic_code_signed is not None:
                    aux_gen = generic_code_signed

                code_dict.update({"generic_op":aux_gen})
            else:
                code_dict.update({"generic_op":fixed_code})

            full_code = genericArithTwoVecPredicated % code_dict

            Iop = InstObjParams(mnemonic,
                full_class_name,
                'UveBaseTwoVecPredicated',
                {'ex_code' : full_code,
                'op_class': 'SimdAluOp'},
                [])

            header_output += UveTwoVecPredicatedDeclare.subst(Iop)
            exec_output += UveTwoVecPredicatedExecute.subst(Iop)
            exec_output += UveArithExecDeclare.subst(Iop)

    # JMNOTE: 2VecPredicatedFPInsts (Reduction specific: Adde,Mine)
    def emitUveArithTwoVecReductionPredicatedFPInsts(mnemonic, class_name,
                                    dest_code, generic_code = None,
                                    generic_code_float = None,
                                    generic_code_signed = None,
                                    acc_initial_value = None):
        global header_output, exec_output, decoders

        genericArithThreeVecPredicated = '''
        auto src1_vc = (TheISA::VecRegContainer)Vs1_x;
        %(acc_type)s out = %(acc_initial_value)s;
        switch(src1_vw){
            case 0:{
                auto v1 = src1_vc.as<%(type8)s>();
                for(int i=0;i<iCount;i++){
                   %(generic_op)s
                }
            }
            break;
            case 1:{
                auto v1 = src1_vc.as<%(type16)s>();
                for(int i=0;i<iCount;i++){
                   %(generic_op)s
                }
            }
            break;
            case 2: {
                auto v1 = src1_vc.as<%(type32)s>();
                for(int i=0;i<iCount;i++){
                   %(generic_op)s
                }
            }
            break;
            default:
            {
                auto v1 = src1_vc.as<%(type64)s>();
                for(int i=0;i<iCount;i++){
                   %(generic_op)s
                }
            }
            break;
        }
        switch(src1_vw){
            case 0:{
                %(dest_code8)s;
            } break;
            case 1:{
                %(dest_code16)s;
            } break;
            case 2:{
                %(dest_code32)s;
            } break;
            default:{
                %(dest_code64)s;
            } break;
        }
        '''
        type_suffixes = ["Unsigned", "Signed", "FP"]

        for idx, suffix in enumerate(type_suffixes):
            full_class_name = class_name + suffix
            code_dict = eval("Type" + suffix)
            aux_dest_code = dest_code % code_dict
            if generic_code is not None:
                if suffix == "FP" and generic_code_float is not None:
                    aux_gen = generic_code_float
                elif suffix == "Signed" and generic_code_signed is not None:
                    aux_gen = generic_code_signed
                else:
                    aux_gen = generic_code
                code_dict.update({"generic_op":aux_gen % code_dict})
            else:
                code_dict.update({"generic_op":fixed_code})
            code_dict.update({"dest_code8" :aux_dest_code %
                                    {"type":code_dict["type8"]},
                              "dest_code16":aux_dest_code %
                                    {"type":code_dict["type16"]},
                              "dest_code32":aux_dest_code %
                                    {"type":code_dict["type32"]},
                              "dest_code64":aux_dest_code %
                                    {"type":code_dict["type64"]}
                              })
            if acc_initial_value is None:
                acc_initial_value = "0";
            code_dict.update({"acc_initial_value": acc_initial_value %
                                                                code_dict})

            full_code = genericArithThreeVecPredicated % code_dict

            Iop = InstObjParams(mnemonic,
                full_class_name,
                'UveBaseTwoVecPredicated',
                {'ex_code' : full_code,
                'op_class': 'SimdAluOp'},
                [])

            header_output += UveTwoVecPredicatedDeclare.subst(Iop)
            exec_output += UveTwoVecPredicatedExecute.subst(Iop)
            exec_output += UveArithExecDeclare.subst(Iop)

    # JMNOTE: 3VecPredicatedInsts Logical
    def emitUveArithLogicThreeVecPredicatedInsts(mnemonic, class_name,
                                    generic_code,
                                    src2 = None, int_types=False,
                                    src2int=False):
        global header_output, exec_output, decoders

        assert(src2 is not None)

        genericArithThreeVecPredicated = '''
        auto src1_vc = (TheISA::VecRegContainer)Vs1_x;
        %(src2_inst)s;
        TheISA::VecRegContainer output;
        switch(src1_vw){
            case 0:{
                auto v1 = src1_vc.as<%(type8)s>();
                %(src2_cast8)s;
                auto out = output.as<%(type8)s>();
                for(int i=0;i<iCount;i++){
                   %(generic_op8)s
                }
            }
            break;
            case 1:{
                auto v1 = src1_vc.as<%(type16)s>();
                %(src2_cast16)s;
                auto out = output.as<%(type16)s>();
                for(int i=0;i<iCount;i++){
                   %(generic_op16)s
                }
            }
            break;
            case 2: {
                auto v1 = src1_vc.as<%(type32)s>();
                %(src2_cast32)s;
                auto out = output.as<%(type32)s>();
                for(int i=0;i<iCount;i++){
                   %(generic_op32)s
                }
            }
            break;
            default:
            {
                auto v1 = src1_vc.as<%(type64)s>();
                %(src2_cast64)s;
                auto out = output.as<%(type64)s>();
                for(int i=0;i<iCount;i++){
                   %(generic_op64)s
                }
            }
            break;
        }

        auto out = output.as<uint8_t>();
        for(int i=0;i<eCount;i++)
            Vd_x[i] = out[i];
        '''
        src2_ops = {
            "src2_inst": "auto src2_vc = (TheISA::VecRegContainer)Vs2_x;",
            "src2_cast8":  "auto v2 = src2_vc.as<%(type8)s>();",
            "src2_cast16":  "auto v2 = src2_vc.as<%(type16)s>();",
            "src2_cast32":  "auto v2 = src2_vc.as<%(type32)s>();",
            "src2_cast64":  "auto v2 = src2_vc.as<%(type64)s>();"
        } if src2 else {"src2_inst": "",
            "src2_cast8":"","src2_cast16":"","src2_cast32":"","src2_cast64":""}

        code_dict = TypeUnsigned if not int_types else TypeSigned
        src2_code_dict = code_dict if not src2int else TypeSigned

        src2_subst = {}
        for key, val in src2_ops.items():
            src2_subst[key] = val % src2_code_dict

        code_dict.update({"generic_op8" :generic_code %
                                    {"type":code_dict["type8"]},
                              "generic_op16":generic_code %
                                    {"type":code_dict["type16"]},
                              "generic_op32":generic_code %
                                    {"type":code_dict["type32"]},
                              "generic_op64":generic_code %
                                    {"type":code_dict["type64"]}
                              })
        code_dict.update(src2_subst)
        full_code = genericArithThreeVecPredicated % code_dict

        Iop = InstObjParams(mnemonic,
            class_name,
            'UveBaseThreeVecPredicated' if src2 else \
                                "UveBaseTwoVecPredicated",
            {'ex_code' : full_code,
            'op_class': 'SimdAluOp'},
            [])

        DeclarerTemplate = UveThreeVecPredicatedDeclare if src2 else \
                        UveTwoVecPredicatedDeclare

        ExecuterTemplate = UveThreeVecPredicatedExecute if src2 else \
                        UveTwoVecPredicatedExecute

        header_output += DeclarerTemplate.subst(Iop)
        exec_output += ExecuterTemplate.subst(Iop)
        exec_output += UveArithExecDeclare.subst(Iop)

    # JMNOTE: Vec + Scalar Shift Insts (slls,srls,sras)
    def emitUveArithLogicShiftVecScaPredicatedInsts(mnemonic, class_name,
                                    generic_code, int_types=False):
        global header_output, exec_output, decoders

        genericArithThreeVecPredicated = '''
        auto src1_vc = (TheISA::VecRegContainer)Vs1_x;
        TheISA::VecRegContainer output;
        switch(src1_vw){
            case 0:{
                auto v1 = src1_vc.as<%(type8)s>();
                auto out = output.as<%(type8)s>();
                for(int i=0;i<iCount;i++){
                   %(generic_op8)s
                }
            }
            break;
            case 1:{
                auto v1 = src1_vc.as<%(type16)s>();
                auto out = output.as<%(type16)s>();
                for(int i=0;i<iCount;i++){
                   %(generic_op16)s
                }
            }
            break;
            case 2: {
                auto v1 = src1_vc.as<%(type32)s>();
                auto out = output.as<%(type32)s>();
                for(int i=0;i<iCount;i++){
                   %(generic_op32)s
                }
            }
            break;
            default:
            {
                auto v1 = src1_vc.as<%(type64)s>();
                auto out = output.as<%(type64)s>();
                for(int i=0;i<iCount;i++){
                   %(generic_op64)s
                }
            }
            break;
        }

        auto out = output.as<uint8_t>();
        for(int i=0;i<eCount;i++)
            Vd_x[i] = out[i];
        '''

        code_dict = TypeUnsigned if not int_types else TypeSigned

        code_dict.update({"generic_op8" :generic_code %
                                    {"type":code_dict["type8"]},
                              "generic_op16":generic_code %
                                    {"type":code_dict["type16"]},
                              "generic_op32":generic_code %
                                    {"type":code_dict["type32"]},
                              "generic_op64":generic_code %
                                    {"type":code_dict["type64"]}
                              })
        full_code = genericArithThreeVecPredicated % code_dict

        Iop = InstObjParams(mnemonic,
            class_name,
            'UveBaseVecScaPredicated',
            {'ex_code' : full_code,
            'op_class': 'SimdAluOp'},
            [])

        header_output += UveVecScaPredicatedDeclare.subst(Iop)
        exec_output += UveVecScaPredicatedExecute.subst(Iop)
        exec_output += UveArithExecDeclare.subst(Iop)


    emitUveArithThreeVecPredicatedFPInsts("so.a.add", "UveArithAdd", "+")
    emitUveArithThreeVecPredicatedFPInsts("so.a.sub", "UveArithSub", "-")
    emitUveArithThreeVecPredicatedFPInsts("so.a.mul", "UveArithMul", "*")
    emitUveArithThreeVecPredicatedFPInsts("so.a.div", "UveArithDiv",
        generic_code='''
        if (v2[i] == 0) {
            out[i] = numeric_limits<uint64_t>::max();
        } else {
            out[i] = v1[i]/v2[i];
        }
        ''',
        generic_code_float= '''
        if (std::isnan(v1[i]) || std::isnan(v2[i])) {
            out[i] = numeric_limits<double>::quiet_NaN();
        } else {
            out[i] = (float)((double)v1[i]/(double)v2[i]);
        }
        ''',
        generic_code_signed='''
         if (v2[i] == 0) {
            out[i] = -1;
        } else if (v1[i] == numeric_limits<int64_t>::min()
                && v2[i] == -1) {
            out[i] = numeric_limits<int64_t>::min();
        } else {
            out[i] = v1[i]/v2[i];
        }
        ''')
    emitUveArithThreeVecPredicatedFPInsts("so.a.mac", "UveArithMac",
        generic_code="out[i]=v3[i] + (v1[i]*v2[i]);", dest_as_source=True)
    emitUveArithThreeVecPredicatedFPInsts("so.a.max", "UveArithMax",
        generic_code="out[i]= uveMax(v1[i],v2[i]);")
    emitUveArithThreeVecPredicatedFPInsts("so.a.min", "UveArithMin",
        generic_code="out[i]= uveMin(v1[i],v2[i]);")

    emitUveArithTwoVecPredicatedFPInsts("so.a.inc", "UveArithInc", "uveInc")
    emitUveArithTwoVecPredicatedFPInsts("so.a.dec", "UveArithDec", "uveDec")


    emitUveArithTwoVecPredicatedFPoInsts("so.a.abs", "UveArithAbs", "uveAbs")


    emitUveArithTwoVecReductionPredicatedFPInsts("so.a.adde", "UveArithAdde",
        dest_code='''
        uint8_t aux = 0;
        for(int i=0; i<1<<src1_vw; i++){
            aux = (typeCastToBits((%%(type)s)out) >> (8*i)) & 0xFF;
            Vd_x[i] = aux;
        }
        ''',
        generic_code='''
        out = out + v1[i];
        ''')
    emitUveArithTwoVecReductionPredicatedFPInsts("so.a.adde",
        "UveArithAddeAcc",
        dest_code='''
        uint8_t aux = 0;

        auto vd_cont = (TheISA::VecRegContainer) Vd_merge_x;
        %(acc_type)s src_aux = 0;
        switch(src1_vw){
            case 0:{
                auto vd_vec = vd_cont.as<%(type8)s>();
                src_aux = vd_vec[0];
            } break;
            case 1:{
                auto vd_vec = vd_cont.as<%(type16)s>();
                src_aux = vd_vec[0];
            } break;
            case 2:{
                auto vd_vec = vd_cont.as<%(type32)s>();
                src_aux = vd_vec[0];
            } break;
            default:{
                auto vd_vec = vd_cont.as<%(type64)s>();
                src_aux = vd_vec[0];
            } break;
        }
        out = out + src_aux;

        for(int i=0; i<1<<src1_vw; i++){
            aux = (typeCastToBits((%%(type)s)out) >> (8*i)) & 0xFF;
            Vd_x[i] = aux;
        }
        ''',
        generic_code='''
        out = out + v1[i];
        ''')
    emitUveArithTwoVecReductionPredicatedFPInsts("so.a.adds", "UveArithAdds",
        dest_code='''
        Rd_ud = typeCastToBits(out);
        ''',
        generic_code='''
        out = out + v1[i];
        ''')
    emitUveArithTwoVecReductionPredicatedFPInsts("so.a.adds",
        "UveArithAddsAcc",
        dest_code='''
        %(acc_type)s src_aux = 0;
        src_aux = castBitsToRetType<%(acc_type)s>(Rd_merge_ud);
        DPRINTF(UVEArith," src_aux(%%%%.10f)\\n",src_aux);
        DPRINTF(UVEArith," out(%%%%.10f)\\n",out);
        Rd_ud = typeCastToBits(src_aux + out);
        ''',
        generic_code='''
        out = out + v1[i];
        ''')
    emitUveArithTwoVecReductionPredicatedFPInsts("so.a.mins", "UveArithMins",
        dest_code='''
        Rd_ud = typeCastToBits(out);
        ''',
        generic_code='''
        out = uveMin(out, (%(acc_type)s) v1[i]);
        ''', acc_initial_value="numeric_limits<%(acc_type)s>::max()")
    emitUveArithTwoVecReductionPredicatedFPInsts("so.a.maxs", "UveArithMaxs",
        dest_code='''
        Rd_ud = typeCastToBits(out);
        ''',
        generic_code='''
        out = uveMax(out, (%(acc_type)s) v1[i]);
        ''', acc_initial_value="numeric_limits<%(acc_type)s>::min()")


    emitUveArithLogicThreeVecPredicatedInsts("so.a.NAND", "UveArithNAND",
    '''
        out[i] = !(v1[i]&v2[i]);
    ''', src2=True)
    emitUveArithLogicThreeVecPredicatedInsts("so.a.AND", "UveArithAND",
    '''
        out[i] = (v1[i]&v2[i]);
    ''', src2=True)
    emitUveArithLogicThreeVecPredicatedInsts("so.a.NOR", "UveArithNOR",
    '''
        out[i] = !(v1[i]|v2[i]);
    ''', src2=True)
    emitUveArithLogicThreeVecPredicatedInsts("so.a.OR", "UveArithOR",
    '''
        out[i] = (v1[i]|v2[i]);
    ''', src2=True)
    emitUveArithLogicThreeVecPredicatedInsts("so.a.NOT", "UveArithNOT",
    '''
        out[i] = !(v1[i]);
    ''', src2=False)
    emitUveArithLogicThreeVecPredicatedInsts("so.a.XOR", "UveArithXOR",
    '''
        out[i] = (v1[i]^v2[i]);
    ''', src2=True)
    emitUveArithLogicThreeVecPredicatedInsts("so.a.SLL", "UveArithSLL",
    '''
        out[i] = v1[i]<<v2[i];
    ''', src2=True, int_types=True, src2int=True)
    emitUveArithLogicThreeVecPredicatedInsts("so.a.SRL", "UveArithSRL",
    '''
        %(type)s aux = (%(type)s) typeCastToBits(v1[i]);
        out[i] = aux>>v2[i];
    ''', src2=True, int_types=False, src2int=True)
    emitUveArithLogicThreeVecPredicatedInsts("so.a.SRA", "UveArithSRA",
    '''
        out[i] = v1[i]>>v2[i];
    ''', src2=True, int_types=True, src2int=True)


    emitUveArithLogicShiftVecScaPredicatedInsts("so.a.SLLS", "UveArithSLLS",
    '''
        out[i] = v1[i]<<Rs2_sd;
    ''',int_types=True);
    emitUveArithLogicShiftVecScaPredicatedInsts("so.a.SRLS", "UveArithSRLS",
    '''
        %(type)s aux = (%(type)s) typeCastToBits(v1[i]);
        out[i] = aux>>Rs2_sd;
    # ''',int_types=False)
    emitUveArithLogicShiftVecScaPredicatedInsts("so.a.SRLS", "UveArithSRAS",
    '''
        out[i] = v1[i]>>Rs2_sd;
    ''',int_types=True)


}};