/////////////////////////////////
//
// Uve vector arithmetic operations instructions definition
// -----------------
// Jo√£o Domingos
//

output header {{

    template <class BaseU, class BaseS, class BaseFP>
    StaticInstPtr
    decodeThreeVecPredicatedFPTemplated(const char * mn, uint8_t signed_fp,
                                ExtMachInst machInst,
                                uint8_t rd,
                                uint8_t rs1,
                                uint8_t rs2,
                                uint8_t ps3)
    {
        switch (signed_fp) {
            case 0x0: // Unsigned
                return new BaseU(mn, machInst, rd, rs1, rs2, ps3);
                break;
            case 0x2: // Signed
                return new BaseS(mn, machInst, rd, rs1, rs2, ps3);
                break;
            default: // Floating Point
                return new BaseFP(mn, machInst, rd, rs1, rs2, ps3);
                break;
        }
    }

    template <class BaseU, class BaseS, class BaseFP>
    StaticInstPtr
    decodeTwoVecPredicatedFPTemplated(const char * mn, uint8_t signed_fp,
                                ExtMachInst machInst,
                                uint8_t rd,
                                uint8_t rs1,
                                uint8_t ps3)
    {
        switch (signed_fp) {
            case 0x0: // Unsigned
                return new BaseU(mn, machInst, rd, rs1, ps3);
                break;
            case 0x2: // Signed
                return new BaseS(mn, machInst, rd, rs1, ps3);
                break;
            default: // Floating Point
                return new BaseFP(mn, machInst, rd, rs1, ps3);
                break;
        }
    }

    template <class BaseS, class BaseFP>
    StaticInstPtr
    decodeTwoVecPredicatedFPoTemplated(const char * mn, uint8_t signed_fp,
                                ExtMachInst machInst,
                                uint8_t rd,
                                uint8_t rs1,
                                uint8_t ps3)
    {
        switch (signed_fp & 0b01) {
            case 0x1: // Floating Point
                return new BaseFP(mn, machInst, rd, rs1, ps3);
                break;
            default: // Signed
                return new BaseS(mn, machInst, rd, rs1, ps3);
                break;
        }
    }
}};

let {{
    header_output = ''
    exec_output = ''
    decoders = { 'Generic': {} }

    TypeUnsigned = {
        'type8': 'uint8_t',
        'type16': 'uint16_t',
        'type32': 'uint32_t',
        'type64': 'uint64_t',
        'acc_type': 'uint64_t'
    }
    TypeSigned = {
        'type8': 'int8_t',
        'type16': 'int16_t',
        'type32': 'int32_t',
        'type64': 'int64_t',
        'acc_type': 'int64_t'
    }
    TypeFP = {
        'type8': 'uint8_t',
        'type16': 'uint16_t',
        'type32': 'float',
        'type64': 'double',
        'acc_type': 'double'
    }


    # JMNOTE: 3VecPredicatedFPInsts
    def emitUveArithThreeVecPredicatedFPInsts(mnemonic, class_name,
                                    code = None, generic_code = None,
                                    generic_code_float = None,
                                    generic_code_signed = None,
                                    dest_as_source = False, op_class = "Alu"):
        global header_output, exec_output, decoders

        genericArithThreeVecPredicated = '''
        unsigned iCount = 0;
        auto src1_vc = (TheISA::VecRegContainer)Vs1_x;
        auto src2_vc = (TheISA::VecRegContainer)Vs2_x;
        auto src1_vw = src1_vc.get_width();
        auto src2_vw = src2_vc.get_width();
        auto src1_lt = src1_vc.get_last();
        auto src2_lt = src2_vc.get_last();
        auto src1_vi = src1_vc.get_valid() / (1 << src1_vw);
        auto src2_vi = src2_vc.get_valid() / (1 << src1_vw);
        auto dest_vi = get_dest_valid_index(src1_vi, src2_vi);
        auto p3_vc = (TheISA::VecPredRegContainer)Ps3_x;
        %(inst)s;
        TheISA::VecRegContainer output;

        if(check_equal_src_widths(src1_vw, src2_vw) &&
                                        src1_vi > 0 &&
                                        src2_vi > 0 ){
            iCount = UVEMIN(eCount / (1<<src1_vw),dest_vi);
            switch(src1_vw){
                case 0:{
                    auto v1 = src1_vc.as<%(type8)s>();
                    auto v2 = src2_vc.as<%(type8)s>();
                    auto p  = p3_vc.as<%(type8)s>();
                    auto out = output.as<%(type8)s>();
                    %(cast8)s;
                    for(int i=0;i<iCount;i++){
                        if(p[i]){
                            %(generic_op)s
                        }
                    }
                }
                break;
                case 1:{
                    auto v1 = src1_vc.as<%(type16)s>();
                    auto v2 = src2_vc.as<%(type16)s>();
                    auto p  = p3_vc.as<%(type16)s>();
                    auto out = output.as<%(type16)s>();
                    %(cast16)s;
                    for(int i=0;i<iCount;i++){
                        if(p[i]){
                            %(generic_op)s
                        }
                    }
                }
                break;
                case 2: {
                    auto v1 = src1_vc.as<%(type32)s>();
                    auto v2 = src2_vc.as<%(type32)s>();
                    auto p  = p3_vc.as<%(type32)s>();
                    auto out = output.as<%(type32)s>();
                    %(cast32)s;
                    for(int i=0;i<iCount;i++){
                        if(p[i]){
                            %(generic_op)s
                        }
                    }
                }
                break;
                default:
                {
                    auto v1 = src1_vc.as<%(type64)s>();
                    auto v2 = src2_vc.as<%(type64)s>();
                    auto p  = p3_vc.as<%(type64)s>();
                    auto out = output.as<%(type64)s>();
                    %(cast64)s;
                    for(int i=0;i<iCount;i++){
                        if(p[i]){
                            %(generic_op)s
                        }
                    }
                }
                break;
            }

            auto out = output.as<uint8_t>();
            for(int i=0;i<eCount;i++)
                Vd_x[i] = out[i];

            Vd_x <= src1_vw;
            Vd_x <<= iCount * (1 << src1_vw);
            Vd_x &= src1_lt | src2_lt;
        } else {
            Vd_x <= src1_vw;
            Vd_x <<= 0;
            Vd_x &= src1_lt | src2_lt;
        }
        '''

        generic_fixed_code = "out[i] = v1[i] %(op)s v2[i];"

        dest_ops = {
            "inst": "auto dest_vc = (TheISA::VecRegContainer)Vd_merge_x;",
            "cast8":  "auto v3 = dest_vc.as<%(type8)s>();",
            "cast16":  "auto v3 = dest_vc.as<%(type16)s>();",
            "cast32":  "auto v3 = dest_vc.as<%(type32)s>();",
            "cast64":  "auto v3 = dest_vc.as<%(type64)s>();"
        } if dest_as_source else {"inst": "",
            "cast8":"","cast16":"","cast32":"","cast64":""}


        type_suffixes = ["Unsigned", "Signed", "FP"]

        if code is not None:
            fixed_code = generic_fixed_code % {"op":code}

        for idx, suffix in enumerate(type_suffixes):
            full_class_name = class_name + suffix
            code_dict = eval("Type" + suffix)

            dest_op = {}
            for key, val in dest_ops.items():
               dest_op[key] = val % code_dict

            if generic_code is not None:
                if suffix == "FP" and generic_code_float is not None:
                    aux_gen = generic_code_float
                elif suffix == "Signed" and generic_code_signed is not None:
                    aux_gen = generic_code_signed
                else:
                    aux_gen = generic_code
                code_dict.update({"generic_op":aux_gen})
            else:
                code_dict.update({"generic_op":fixed_code})
            code_dict.update(dest_op)
            full_code = genericArithThreeVecPredicated % code_dict

            Iop = InstObjParams(mnemonic,
                full_class_name,
                'UveBaseThreeVecPredicated',
                {'ex_code' : full_code,
                'op_class': 'Simd'+('Float' if (suffix=="FP") else "") +
                    op_class +"Op"},
                ['IsStreamInst'])

            header_output += UveThreeVecPredicatedDeclare.subst(Iop)
            exec_output += UveThreeVecPredicatedExecute.subst(Iop)
            exec_output += UveArithExecDeclare.subst(Iop)

    # JMNOTE: 2VecPredicatedFPInsts (inc, dec)
    def emitUveArithTwoVecPredicatedFPInsts(mnemonic, class_name,
                                    code = None,
                                    generic_code_float = None,
                                    generic_code_signed = None,
                                    op_class = "Alu"):
        global header_output, exec_output, decoders

        genericArithTwoVecPredicated = '''
        auto src1_vc = (TheISA::VecRegContainer)Vs1_x;
        auto src1_vw = src1_vc.get_width();
        auto src1_vi = src1_vc.get_valid() / (1 << src1_vw);
        unsigned iCount = eCount /  (1<<src1_vw);
        iCount = UVEMIN(iCount,src1_vi);
        auto p3_vc = (TheISA::VecPredRegContainer)Ps3_x;
        TheISA::VecRegContainer output;
        switch(src1_vw){
            case 0:{
                auto v1 = src1_vc.as<%(type8)s>();
                auto p  = p3_vc.as<%(type8)s>();
                auto out = output.as<%(type8)s>();
                for(int i=0;i<iCount;i++){
                    if(p[i]){
                        %(generic_op)s
                    }
                }
            }
            break;
            case 1:{
                auto v1 = src1_vc.as<%(type16)s>();
                auto p  = p3_vc.as<%(type16)s>();
                auto out = output.as<%(type16)s>();
                for(int i=0;i<iCount;i++){
                    if(p[i]){
                        %(generic_op)s
                    }
                }
            }
            break;
            case 2: {
                auto v1 = src1_vc.as<%(type32)s>();
                auto p  = p3_vc.as<%(type32)s>();
                auto out = output.as<%(type32)s>();
                for(int i=0;i<iCount;i++){
                    if(p[i]){
                        %(generic_op)s
                    }
                }
            }
            break;
            default:
            {
                auto v1 = src1_vc.as<%(type64)s>();
                auto p  = p3_vc.as<%(type64)s>();
                auto out = output.as<%(type64)s>();
                for(int i=0;i<iCount;i++){
                    if(p[i]){
                        %(generic_op)s
                    }
                }
            }
            break;
        }

        auto out = output.as<uint8_t>();
        for(int i=0;i<eCount;i++)
            Vd_x[i] = out[i];

        Vd_x <= src1_vw;
        Vd_x <<= iCount * (1 << src1_vw);
        '''

        generic_fixed_code = "out[i] = %(op)s(v1[i]);"


        type_suffixes = ["Unsigned", "Signed", "FP"]

        if code is not None:
            fixed_code = generic_fixed_code % {"op":code}

        for idx, suffix in enumerate(type_suffixes):
            full_class_name = class_name + suffix
            code_dict = eval("Type" + suffix)
            if code is None:
                if suffix == "FP" and generic_code_float is not None:
                    aux_gen = generic_code_float
                elif suffix == "Signed" and generic_code_signed is not None:
                    aux_gen = generic_code_signed
                else:
                    aux_gen = generic_code
                code_dict.update({"generic_op":aux_gen})
            else:
                code_dict.update({"generic_op":fixed_code})

            full_code = genericArithTwoVecPredicated % code_dict

            Iop = InstObjParams(mnemonic,
                full_class_name,
                'UveBaseTwoVecPredicated',
                {'ex_code' : full_code,
                'op_class': 'Simd'+('Float' if (suffix=="FP") else "") +
                    op_class +"Op"},
                ['IsStreamInst'])

            header_output += UveTwoVecPredicatedDeclare.subst(Iop)
            exec_output += UveTwoVecPredicatedExecute.subst(Iop)
            exec_output += UveArithExecDeclare.subst(Iop)

    # JMNOTE: 2VecPredicatedFPoInsts FPonly -> No unsigned code (abs, mod)
    def emitUveArithTwoVecPredicatedFPoInsts(mnemonic, class_name,
                                    code = None,
                                    generic_code_float = None,
                                    generic_code_signed = None,
                                    op_class = "Alu"):
        global header_output, exec_output, decoders

        genericArithTwoVecPredicated = '''
        auto src1_vc = (TheISA::VecRegContainer)Vs1_x;
        auto p3_vc = (TheISA::VecPredRegContainer)Ps3_x;
        auto src1_vw = src1_vc.get_width();
        auto src1_vi = src1_vc.get_valid() / (1 << src1_vw);
        unsigned iCount = eCount /  (1<<src1_vw);
        iCount = UVEMIN(iCount,src1_vi);
        TheISA::VecRegContainer output;
        switch(src1_vw){
            case 0:{
                auto v1 = src1_vc.as<%(type8)s>();
                auto p  = p3_vc.as<%(type8)s>();
                auto out = output.as<%(type8)s>();
                for(int i=0;i<iCount;i++){
                    if(p[i]){
                        %(generic_op)s
                    }
                }
            }
            break;
            case 1:{
                auto v1 = src1_vc.as<%(type16)s>();
                auto p  = p3_vc.as<%(type16)s>();
                auto out = output.as<%(type16)s>();
                for(int i=0;i<iCount;i++){
                    if(p[i]){
                        %(generic_op)s
                    }
                }
            }
            break;
            case 2: {
                auto v1 = src1_vc.as<%(type32)s>();
                auto p  = p3_vc.as<%(type32)s>();
                auto out = output.as<%(type32)s>();
                for(int i=0;i<iCount;i++){
                    if(p[i]){
                        %(generic_op)s
                    }
                }
            }
            break;
            default:
            {
                auto v1 = src1_vc.as<%(type64)s>();
                auto p  = p3_vc.as<%(type64)s>();
                auto out = output.as<%(type64)s>();
                for(int i=0;i<iCount;i++){
                    if(p[i]){
                        %(generic_op)s
                    }
                }
            }
            break;
        }

        auto out = output.as<uint8_t>();
        for(int i=0;i<eCount;i++)
            Vd_x[i] = out[i];

        Vd_x <= src1_vw;
        Vd_x <<= iCount * (1 << src1_vw);
        '''

        generic_fixed_code = "out[i] = %(op)s(v1[i]);"


        type_suffixes = ["Signed", "FP"]

        if code is not None:
            fixed_code = generic_fixed_code % {"op":code}

        for idx, suffix in enumerate(type_suffixes):
            full_class_name = class_name + suffix
            code_dict = eval("Type" + suffix)
            if code is None:
                if suffix == "FP" and generic_code_float is not None:
                    aux_gen = generic_code_float
                elif suffix == "Signed" and generic_code_signed is not None:
                    aux_gen = generic_code_signed

                code_dict.update({"generic_op":aux_gen})
            else:
                code_dict.update({"generic_op":fixed_code})

            full_code = genericArithTwoVecPredicated % code_dict

            Iop = InstObjParams(mnemonic,
                full_class_name,
                'UveBaseTwoVecPredicated',
                {'ex_code' : full_code,
                'op_class': 'Simd'+('Float' if (suffix=="FP") else "") +
                    op_class +"Op"},
                ['IsStreamInst'])

            header_output += UveTwoVecPredicatedDeclare.subst(Iop)
            exec_output += UveTwoVecPredicatedExecute.subst(Iop)
            exec_output += UveArithExecDeclare.subst(Iop)

    # JMNOTE: 2VecPredicatedFPInsts (Reduction specific: Adde,Mine)
    def emitUveArithTwoVecReductionPredicatedFPInsts(mnemonic, class_name,
                                    dest_code, generic_code = None,
                                    generic_code_float = None,
                                    generic_code_signed = None,
                                    acc_initial_value = None,
                                    dest_scalar = False, op_class = "Alu",
                                    dest_code_scalar = None):
        global header_output, exec_output, decoders
        #JMFIXME: Correct the predicates here
        genericArithThreeVecPredicated = '''
        auto src1_vc = (TheISA::VecRegContainer)Vs1_x;
        %(acc_type)s out = %(acc_initial_value)s;
        auto src1_vw = src1_vc.get_width();
        auto src1_vi = src1_vc.get_valid() / (1 << src1_vw);
        unsigned iCount = eCount /  (1<<src1_vw);
        iCount = UVEMIN(iCount,src1_vi);
        switch(src1_vw){
            case 0:{
                auto v1 = src1_vc.as<%(type8)s>();
                for(int i=0;i<iCount;i++){
                    if(Ps3_x[i]){
                        %(generic_op)s
                    }
                }
            }
            break;
            case 1:{
                auto v1 = src1_vc.as<%(type16)s>();
                for(int i=0;i<iCount;i++){
                    if(Ps3_x[i]){
                        %(generic_op)s
                    }
                }
            }
            break;
            case 2: {
                auto v1 = src1_vc.as<%(type32)s>();
                for(int i=0;i<iCount;i++){
                    if(Ps3_x[i]){
                        %(generic_op)s
                    }
                }
            }
            break;
            default:
            {
                auto v1 = src1_vc.as<%(type64)s>();
                for(int i=0;i<iCount;i++){
                    if(Ps3_x[i]){
                        %(generic_op)s
                    }
                }
            }
            break;
        }
        switch(src1_vw){
            case 0:{
                %(dest_code8)s;
            } break;
            case 1:{
                %(dest_code16)s;
            } break;
            case 2:{
                %(dest_code32)s;
            } break;
            default:{
                %(dest_code64)s;
            } break;
        }
        '''
        type_suffixes = ["Unsigned", "Signed", "FP"]

        for idx, suffix in enumerate(type_suffixes):
            full_class_name = class_name + suffix
            code_dict = eval("Type" + suffix)
            if suffix != "FP" and dest_code_scalar is not None:
                aux_dest_code = dest_code_scalar % code_dict
            else:
                aux_dest_code = dest_code % code_dict
            if generic_code is not None:
                if suffix == "FP" and generic_code_float is not None:
                    aux_gen = generic_code_float
                elif suffix == "Signed" and generic_code_signed is not None:
                    aux_gen = generic_code_signed
                else:
                    aux_gen = generic_code
                code_dict.update({"generic_op":aux_gen % code_dict})
            else:
                code_dict.update({"generic_op":fixed_code})
            code_dict.update({"dest_code8" :aux_dest_code %
                                    {"type":code_dict["type8"]},
                              "dest_code16":aux_dest_code %
                                    {"type":code_dict["type16"]},
                              "dest_code32":aux_dest_code %
                                    {"type":code_dict["type32"]},
                              "dest_code64":aux_dest_code %
                                    {"type":code_dict["type64"]}
                              })
            if acc_initial_value is None:
                acc_initial_value = "0";
            code_dict.update({"acc_initial_value": acc_initial_value %
                                                                code_dict})

            full_code = genericArithThreeVecPredicated % code_dict

            Iop = InstObjParams(mnemonic,
                full_class_name,
                'UveBaseTwoVecPredicated' if not dest_scalar
                    else 'UveBaseTwoVec2ScaPredicated',
                {'ex_code' : full_code,
                'op_class': 'Simd'+('Float' if (suffix=="FP") else "") +
                    op_class +"Op"},
                ['IsStreamInst'])

            header_output += \
                UveTwoVecPredicatedDeclare.subst(Iop) if not dest_scalar \
                    else UveTwoVec2ScaPredicatedDeclare.subst(Iop)
            exec_output += \
                UveTwoVecPredicatedExecute.subst(Iop) if not dest_scalar \
                    else UveTwoVec2ScaPredicatedExecute.subst(Iop)
            exec_output += UveArithExecDeclare.subst(Iop)

    # JMNOTE: 3VecPredicatedInsts Logical
    def emitUveArithLogicThreeVecPredicatedInsts(mnemonic, class_name,
                                    generic_code,
                                    src2 = None, int_types=False,
                                    src2int=False, op_class="Alu"):
        global header_output, exec_output, decoders

        assert(src2 is not None)

        genericArithThreeVecPredicated = '''
        auto src1_vc = (TheISA::VecRegContainer)Vs1_x;
        %(src2_inst)s;
        auto src1_vw = src1_vc.get_width();
        auto src1_vi = src1_vc.get_valid() / (1 << src1_vw);
        unsigned iCount = eCount /  (1<<src1_vw);
        iCount = UVEMIN(iCount,src1_vi);
        auto p3_vc = (TheISA::VecPredRegContainer)Ps3_x;
        TheISA::VecRegContainer output;
        switch(src1_vw){
            case 0:{
                auto v1 = src1_vc.as<%(type8)s>();
                %(src2_cast8)s;
                auto p  = p3_vc.as<%(type8)s>();
                auto out = output.as<%(type8)s>();
                for(int i=0;i<iCount;i++){
                    if(p[i]){
                        %(generic_op8)s
                    }
                }
            }
            break;
            case 1:{
                auto v1 = src1_vc.as<%(type16)s>();
                %(src2_cast16)s;
                auto p  = p3_vc.as<%(type16)s>();
                auto out = output.as<%(type16)s>();
                for(int i=0;i<iCount;i++){
                    if(p[i]){
                        %(generic_op16)s
                    }
                }
            }
            break;
            case 2: {
                auto v1 = src1_vc.as<%(type32)s>();
                %(src2_cast32)s;
                auto p  = p3_vc.as<%(type32)s>();
                auto out = output.as<%(type32)s>();
                for(int i=0;i<iCount;i++){
                    if(p[i]){
                        %(generic_op32)s
                    }
                }
            }
            break;
            default:
            {
                auto v1 = src1_vc.as<%(type64)s>();
                %(src2_cast64)s;
                auto p  = p3_vc.as<%(type64)s>();
                auto out = output.as<%(type64)s>();
                for(int i=0;i<iCount;i++){
                    if(p[i]){
                        %(generic_op64)s
                    }
                }
            }
            break;
        }

        auto out = output.as<uint8_t>();
        for(int i=0;i<eCount;i++)
            Vd_x[i] = out[i];
        Vd_x <= src1_vw;
        Vd_x <<= iCount * (1 << src1_vw);
        '''
        src2_ops = {
            "src2_inst": "auto src2_vc = (TheISA::VecRegContainer)Vs2_x;",
            "src2_cast8":  "auto v2 = src2_vc.as<%(type8)s>();",
            "src2_cast16":  "auto v2 = src2_vc.as<%(type16)s>();",
            "src2_cast32":  "auto v2 = src2_vc.as<%(type32)s>();",
            "src2_cast64":  "auto v2 = src2_vc.as<%(type64)s>();"
        } if src2 else {"src2_inst": "",
            "src2_cast8":"","src2_cast16":"","src2_cast32":"","src2_cast64":""}

        code_dict = TypeUnsigned if not int_types else TypeSigned
        src2_code_dict = code_dict if not src2int else TypeSigned

        src2_subst = {}
        for key, val in src2_ops.items():
            src2_subst[key] = val % src2_code_dict

        code_dict.update({"generic_op8" :generic_code %
                                    {"type":code_dict["type8"]},
                              "generic_op16":generic_code %
                                    {"type":code_dict["type16"]},
                              "generic_op32":generic_code %
                                    {"type":code_dict["type32"]},
                              "generic_op64":generic_code %
                                    {"type":code_dict["type64"]}
                              })
        code_dict.update(src2_subst)
        full_code = genericArithThreeVecPredicated % code_dict

        Iop = InstObjParams(mnemonic,
            class_name,
            'UveBaseThreeVecPredicated' if src2 else \
                                "UveBaseTwoVecPredicated",
            {'ex_code' : full_code,
            'op_class': 'Simd'+ op_class +"Op"},
            ['IsStreamInst'])

        DeclarerTemplate = UveThreeVecPredicatedDeclare if src2 else \
                        UveTwoVecPredicatedDeclare

        ExecuterTemplate = UveThreeVecPredicatedExecute if src2 else \
                        UveTwoVecPredicatedExecute

        header_output += DeclarerTemplate.subst(Iop)
        exec_output += ExecuterTemplate.subst(Iop)
        exec_output += UveArithExecDeclare.subst(Iop)

    # JMNOTE: Vec + Scalar Shift Insts (slls,srls,sras)
    def emitUveArithLogicShiftVecScaPredicatedInsts(mnemonic, class_name,
                                    generic_code, int_types=False,
                                    op_class="Alu"):
        global header_output, exec_output, decoders

        genericArithThreeVecPredicated = '''
        auto src1_vc = (TheISA::VecRegContainer)Vs1_x;
        auto src1_vw = src1_vc.get_width();
        uint16_t src1_vi = src1_vc.get_valid() / (1 << src1_vw);
        unsigned iCount = eCount /  (1<<src1_vw);
        iCount = UVEMIN(iCount,src1_vi);
        auto p3_vc = (TheISA::VecPredRegContainer)Ps3_x;
        TheISA::VecRegContainer output;
        switch(src1_vw){
            case 0:{
                auto v1 = src1_vc.as<%(type8)s>();
                auto p  = p3_vc.as<%(type8)s>();
                auto out = output.as<%(type8)s>();
                for(int i=0;i<iCount;i++){
                    if(p[i]){
                        %(generic_op8)s
                    }
                }
            }
            break;
            case 1:{
                auto v1 = src1_vc.as<%(type16)s>();
                auto p  = p3_vc.as<%(type16)s>();
                auto out = output.as<%(type16)s>();
                for(int i=0;i<iCount;i++){
                    if(p[i]){
                        %(generic_op16)s
                    }
                }
            }
            break;
            case 2: {
                auto v1 = src1_vc.as<%(type32)s>();
                auto p  = p3_vc.as<%(type32)s>();
                auto out = output.as<%(type32)s>();
                for(int i=0;i<iCount;i++){
                    if(p[i]){
                        %(generic_op32)s
                    }
                }
            }
            break;
            default:
            {
                auto v1 = src1_vc.as<%(type64)s>();
                auto p  = p3_vc.as<%(type64)s>();
                auto out = output.as<%(type64)s>();
                for(int i=0;i<iCount;i++){
                    if(p[i]){
                        %(generic_op64)s
                    }
                }
            }
            break;
        }

        auto out = output.as<uint8_t>();
        for(int i=0;i<eCount;i++)
            Vd_x[i] = out[i];

        Vd_x <= src1_vw;
        Vd_x <<= iCount * (1 << src1_vw);
        '''

        code_dict = TypeUnsigned if not int_types else TypeSigned

        code_dict.update({"generic_op8" :generic_code %
                                    {"type":code_dict["type8"]},
                              "generic_op16":generic_code %
                                    {"type":code_dict["type16"]},
                              "generic_op32":generic_code %
                                    {"type":code_dict["type32"]},
                              "generic_op64":generic_code %
                                    {"type":code_dict["type64"]}
                              })
        full_code = genericArithThreeVecPredicated % code_dict

        Iop = InstObjParams(mnemonic,
            class_name,
            'UveBaseVecScaPredicated',
            {'ex_code' : full_code,
            'op_class': 'Simd'+ op_class +"Op"},
            ['IsStreamInst'])

        header_output += UveVecScaPredicatedDeclare.subst(Iop)
        exec_output += UveVecScaPredicatedExecute.subst(Iop)
        exec_output += UveArithExecDeclare.subst(Iop)


    emitUveArithThreeVecPredicatedFPInsts("so.a.add", "UveArithAdd", "+",
                                            op_class="Add")
    emitUveArithThreeVecPredicatedFPInsts("so.a.sub", "UveArithSub", "-",
                                            op_class="Add")
    emitUveArithThreeVecPredicatedFPInsts("so.a.mul", "UveArithMul", "*",
                                            op_class="Mult")
    emitUveArithThreeVecPredicatedFPInsts("so.a.div", "UveArithDiv",
        generic_code='''
        if (v2[i] == 0) {
            out[i] = numeric_limits<uint64_t>::max();
        } else {
            out[i] = v1[i]/v2[i];
        }
        ''',
        generic_code_float= '''
        if (std::isnan(v1[i]) || std::isnan(v2[i])) {
            out[i] = numeric_limits<double>::quiet_NaN();
        } else {
            out[i] = (float)((double)v1[i]/(double)v2[i]);
        }
        ''',
        generic_code_signed='''
         if (v2[i] == 0) {
            out[i] = -1;
        } else if (v1[i] == numeric_limits<int64_t>::min()
                && v2[i] == -1) {
            out[i] = numeric_limits<int64_t>::min();
        } else {
            out[i] = v1[i]/v2[i];
        }
        ''', op_class="Div")
    emitUveArithThreeVecPredicatedFPInsts("so.a.mac", "UveArithMac",
        generic_code="out[i]=v3[i] + (v1[i]*v2[i]);", dest_as_source=True,
        op_class="MultAcc")
    emitUveArithThreeVecPredicatedFPInsts("so.a.max", "UveArithMax",
        generic_code="out[i]= uveMax(v1[i],v2[i]);", op_class="Cmp")
    emitUveArithThreeVecPredicatedFPInsts("so.a.min", "UveArithMin",
        generic_code="out[i]= uveMin(v1[i],v2[i]);", op_class="Cmp")

    emitUveArithTwoVecPredicatedFPInsts("so.a.inc", "UveArithInc", "uveInc",
                                        op_class="Add")
    emitUveArithTwoVecPredicatedFPInsts("so.a.dec", "UveArithDec", "uveDec",
                                        op_class="Add")


    emitUveArithTwoVecPredicatedFPoInsts("so.a.abs", "UveArithAbs", "uveAbs",
                                        op_class="Misc")


    emitUveArithTwoVecReductionPredicatedFPInsts("so.a.adde", "UveArithAdde",
        dest_code='''
        uint8_t aux = 0;
        for(int i=0; i<1<<src1_vw; i++){
            aux = (typeCastToBits((%%(type)s)out) >> (8*i)) & 0xFF;
            Vd_x[i] = aux;
        }
        Vd_x <= src1_vw;
        Vd_x <<= iCount * (1 << src1_vw);
        ''',
        generic_code='''
        out = out + v1[i];
        ''',op_class="ReduceAdd")
    emitUveArithTwoVecReductionPredicatedFPInsts("so.a.adde",
        "UveArithAddeAcc",
        dest_code='''
        uint8_t aux = 0;

        auto vd_cont = (TheISA::VecRegContainer) Vd_merge_x;
        %(acc_type)s src_aux = 0;
        switch(src1_vw){
            case 0:{
                auto vd_vec = vd_cont.as<%(type8)s>();
                src_aux = vd_vec[0];
            } break;
            case 1:{
                auto vd_vec = vd_cont.as<%(type16)s>();
                src_aux = vd_vec[0];
            } break;
            case 2:{
                auto vd_vec = vd_cont.as<%(type32)s>();
                src_aux = vd_vec[0];
            } break;
            default:{
                auto vd_vec = vd_cont.as<%(type64)s>();
                src_aux = vd_vec[0];
            } break;
        }
        out = out + src_aux;

        for(int i=0; i<1<<src1_vw; i++){
            aux = (typeCastToBits((%%(type)s)out) >> (8*i)) & 0xFF;
            Vd_x[i] = aux;
        }
        Vd_x <= src1_vw;
        Vd_x <<= iCount * (1 << src1_vw);
        ''',
        generic_code='''
        out = out + v1[i];
        ''', op_class="ReduceAdd")
    emitUveArithTwoVecReductionPredicatedFPInsts("so.a.adds", "UveArithAdds",
        dest_code='''
        DPRINTF(UVEArith, "UveArithAdds->execute: %%%%f \\n", out);
        Fd_bits = typeCastToBits(out);
        ''',
        generic_code='''
        out = out + v1[i];
        ''', dest_scalar=True, op_class="ReduceAdd",
        dest_code_scalar='''
        Rd = typeCastToBits(out);
        ''')
    emitUveArithTwoVecReductionPredicatedFPInsts("so.a.adds.acc",
        "UveArithAddsAcc",
        dest_code='''
        %(acc_type)s src_aux = Fd_merge_df;
        Fd_bits = typeCastToBits(src_aux + out);
        ''',
        generic_code='''
        out = out + v1[i];
        ''', dest_scalar=True, op_class="ReduceAdd",
        dest_code_scalar='''
        %(acc_type)s src_aux = castBitsToRetType<%(acc_type)s>(Rd_merge_s);
        Rd = typeCastToBits(src_aux + out);
        ''')
    emitUveArithTwoVecReductionPredicatedFPInsts("so.a.mins", "UveArithMins",
        dest_code='''
        Rd_ud = typeCastToBits(out);
        ''',
        generic_code='''
        out = uveMin(out, (%(acc_type)s) v1[i]);
        ''', acc_initial_value="numeric_limits<%(acc_type)s>::max()",
        op_class="ReduceCmp")
    emitUveArithTwoVecReductionPredicatedFPInsts("so.a.maxs", "UveArithMaxs",
        dest_code='''
        Rd_ud = typeCastToBits(out);
        ''',
        generic_code='''
        out = uveMax(out, (%(acc_type)s) v1[i]);
        ''', acc_initial_value="numeric_limits<%(acc_type)s>::min()",
        op_class="ReduceAdd")


    emitUveArithLogicThreeVecPredicatedInsts("so.a.NAND", "UveArithNAND",
    '''
        out[i] = !(v1[i]&v2[i]);
    ''', src2=True)
    emitUveArithLogicThreeVecPredicatedInsts("so.a.AND", "UveArithAND",
    '''
        out[i] = (v1[i]&v2[i]);
    ''', src2=True)
    emitUveArithLogicThreeVecPredicatedInsts("so.a.NOR", "UveArithNOR",
    '''
        out[i] = !(v1[i]|v2[i]);
    ''', src2=True)
    emitUveArithLogicThreeVecPredicatedInsts("so.a.OR", "UveArithOR",
    '''
        out[i] = (v1[i]|v2[i]);
    ''', src2=True)
    emitUveArithLogicThreeVecPredicatedInsts("so.a.NOT", "UveArithNOT",
    '''
        out[i] = !(v1[i]);
    ''', src2=False)
    emitUveArithLogicThreeVecPredicatedInsts("so.a.XOR", "UveArithXOR",
    '''
        out[i] = (v1[i]^v2[i]);
    ''', src2=True)
    emitUveArithLogicThreeVecPredicatedInsts("so.a.SLL", "UveArithSLL",
    '''
        out[i] = v1[i]<<v2[i];
    ''', src2=True, int_types=True, src2int=True, op_class="Shift")
    emitUveArithLogicThreeVecPredicatedInsts("so.a.SRL", "UveArithSRL",
    '''
        %(type)s aux = (%(type)s) typeCastToBits(v1[i]);
        out[i] = aux>>v2[i];
    ''', src2=True, int_types=False, src2int=True, op_class="Shift")
    emitUveArithLogicThreeVecPredicatedInsts("so.a.SRA", "UveArithSRA",
    '''
        out[i] = v1[i]>>v2[i];
    ''', src2=True, int_types=True, src2int=True, op_class="Shift")


    emitUveArithLogicShiftVecScaPredicatedInsts("so.a.SLLS", "UveArithSLLS",
    '''
        out[i] = v1[i]<<Rs2_sd;
    ''',int_types=True, op_class="Shift");
    emitUveArithLogicShiftVecScaPredicatedInsts("so.a.SRLS", "UveArithSRLS",
    '''
        %(type)s aux = (%(type)s) typeCastToBits(v1[i]);
        out[i] = aux>>Rs2_sd;
    # ''',int_types=False, op_class="Shift")
    emitUveArithLogicShiftVecScaPredicatedInsts("so.a.SRLS", "UveArithSRAS",
    '''
        out[i] = v1[i]>>Rs2_sd;
    ''',int_types=True, op_class="Shift")


}};