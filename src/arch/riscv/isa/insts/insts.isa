// -*- mode:c++ -*-

//JMNOTE: UVE Template Magic for width conversion with type_traits
// And other helper functions
let {{
    header_output = '''
    #define MEM_PRINTF(mem,dir,vec,count)  DPRINTF(UVEMem, "______________" \
            "__________________\\n"); \
            std::string ss; \
            for (int i = 0; i < count; i++) { \
                ss += "(" + std::to_string(i) + ") M[" + \
                std::to_string(mem[i]) + "]" dir "V[" + \
                std::to_string(vec[i]) + "] -"; \
                if(i % 30 == 29) ss += "\\n"; \
            } \
            DPRINTF(UVEMem, (ss+="\\n").c_str() ); \
            DPRINTF(UVEMem, "________________________________\\n"); \
    '''

    exec_output = '''
    template <class WidthSize>
    struct width_converter{
        static const uint8_t width = 3;
    };
    template <>
    struct width_converter<uint32_t>{
        static const uint8_t width = 2;
    };
    template <>
    struct width_converter<uint16_t>{
        static const uint8_t width = 1;
    };
    template <>
    struct width_converter<uint8_t>{
        static const uint8_t width = 0;
    };
    template <>
    struct width_converter<int32_t>{
        static const uint8_t width = 2;
    };
    template <>
    struct width_converter<int16_t>{
        static const uint8_t width = 1;
    };
    template <>
    struct width_converter<int8_t>{
        static const uint8_t width = 0;
    };    template <>
    struct width_converter<float>{
        static const uint8_t width = 2;
    };

    template <typename Ret>
    Ret convertFP(float& val){return (Ret) val;}
    template <typename Ret>
    Ret convertFP(double& val){return (Ret) val;}

    template <typename Ret>
    Ret convertUInt(uint8_t& val){return ((Ret&) val) & 0xff;}
    template <typename Ret>
    Ret convertUInt(uint16_t& val){return ((Ret&) val) & 0xffff;}
    template <typename Ret>
    Ret convertUInt(uint32_t& val){return ((Ret&) val) & 0xffffffff;}
    template <typename Ret>
    Ret convertUInt(uint64_t& val){return ((Ret&) val);}

    template <typename Ret>
    Ret convertInt(int8_t& val){
        auto aux = ((Ret&) val) & 0xff;
        if((aux >> 7) & 1)
            aux |= ~(0ULL) << 8;
        return aux;
    }
    template <typename Ret>
    Ret convertInt(int16_t& val){
        auto aux = ((Ret&) val) & 0xffff;
        if((aux >> 15) & 1)
            aux |= ~(0ULL) << 16;
        return aux;
    }
    template <typename Ret>
    Ret convertInt(int32_t& val){
        auto aux = ((Ret&) val) & 0xffffffff;
        if((aux >> 31) & 1)
            aux |= ~(0ULL) << 32;
        return aux;
    }
    template <typename Ret>
    Ret convertInt(int64_t& val){
        return ((Ret&) val);
    }

    void check_equal_src_widths(size_t a, size_t b){
        //JMTODO: Use assert in the future
        if(a!=b)
            DPRINTF(UVEArith,"Src widths differ.. invalid src code");
    }

    size_t get_vector_width(ExecContext *xc, uint8_t reg ){
        return RiscvStaticInst::getUveVecType(xc->tcBase(),
            reg);
    }


    template <typename Ret>
    typename enable_if<std::is_integral<Ret>::value, Ret>::type
    uveAbs(Ret& val){
        return abs(val);
    }
    template <typename Ret>
    typename enable_if<std::is_floating_point<Ret>::value, Ret>::type
    uveAbs(Ret& val){
        return fabs(val);
    }


    template <typename Ret>
    Ret castBitsToRetType(uint64_t arg){
        union
        {
            Ret src;
            uint64_t bits;
        } val;
        val.bits = arg;
        return val.src;
    }

    template <typename T>
    uint64_t typeCastToBits(T arg)
    {
        union
        {
            T src;
            uint64_t bits;
        } val;
        val.src = arg;
        return val.bits;
    }
    '''
}};

//UVE
##include "uve_vector_mem.isa"

##include "uve_arithmetic.isa"