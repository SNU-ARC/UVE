/////////////////////////////////
//
// Uve vector memory operations instructions definition
// -----------------
// Jo√£o Domingos
//

output header {{
    template <template<typename Width> class Base>
    StaticInstPtr
    decodeVectorLoadTemplated(  uint8_t load_width,
                                ExtMachInst machInst,
                                uint8_t rd,
                                uint8_t rs1,
                                uint8_t rs2)
    {
        const char* mn = "so.v.ld";
        switch (load_width) {
            case 0x0:
                return new Base<uint8_t>(mn, machInst, rd, rs1, rs2);
                break;
            case 0x1:
                return new Base<uint16_t>(mn, machInst, rd, rs1, rs2);
                break;
            case 0x2:
                return new Base<uint32_t>(mn, machInst, rd, rs1, rs2);
                break;
            default:
                return new Base<uint64_t>(mn, machInst, rd, rs1, rs2);
                break;
        }
    }

    template <template<typename Width> class Base>
    StaticInstPtr
    decodeVectorStoreTemplated(ExtMachInst machInst,
                                uint8_t rd,
                                uint8_t rs1,
                                uint8_t rs2)
    {
        const char* mn = "so.v.st";
        return new Base<uint8_t>(mn, machInst, rd, rs1, rs2);
    }

    template <template<typename Width> class Base>
    StaticInstPtr
    decodeVectorDupTemplated(  uint8_t load_width,
                                ExtMachInst machInst,
                                uint8_t rd,
                                uint8_t rs1,
                                uint8_t ps2)
    {
        const char* mn = "so.v.dp";
        switch (load_width) {
            case 0x0:
                return new Base<uint8_t>(mn, machInst, rd, rs1, ps2);
                break;
            case 0x1:
                return new Base<uint16_t>(mn, machInst, rd, rs1, ps2);
                break;
            case 0x2:
                return new Base<uint32_t>(mn, machInst, rd, rs1, ps2);
                break;
            default:
                return new Base<uint64_t>(mn, machInst, rd, rs1, ps2);
                break;
        }
    }

    template <template<typename Width> class Base>
    StaticInstPtr
    decodeVectorMoveSVTemplated(  uint8_t load_width,
                                ExtMachInst machInst,
                                uint8_t rd,
                                uint8_t rs1,
                                uint8_t ps2 = 0)
    {
        const char* mn = "so.v.mvsv";
        switch (load_width) {
            case 0x0:
                return new Base<uint8_t>(mn, machInst, rd, rs1, ps2);
                break;
            case 0x1:
                return new Base<uint16_t>(mn, machInst, rd, rs1, ps2);
                break;
            case 0x2:
                return new Base<uint32_t>(mn, machInst, rd, rs1, ps2);
                break;
            default:
                return new Base<uint64_t>(mn, machInst, rd, rs1, ps2);
                break;
        }
    }

    template <template<typename Width> class Base>
    StaticInstPtr
    decodeVectorMoveTemplated(ExtMachInst machInst,
                                uint8_t rd,
                                uint8_t rs1,
                                uint8_t ps2)
    {
        const char* mn = "so.v.mv";
        return new Base<uint8_t>(mn, machInst, rd, rs1, ps2);
    }

    template <template<typename Width> class Base>
    StaticInstPtr
    decodeVectorMoveVSTemplated(ExtMachInst machInst,
                                uint8_t rd,
                                uint8_t rs1,
                                uint8_t ps2 = 0)
    {
        const char* mn = "so.v.mvvs";
        return new Base<uint8_t>(mn, machInst, rd, rs1, ps2);
    }

    template <template<typename Width> class Base>
    StaticInstPtr
    decodeVectorConvTemplatedUnsigned(  uint8_t load_width,
                                ExtMachInst machInst,
                                uint8_t rd,
                                uint8_t rs1)
    {
        const char* mn = "so.v.cv";
        switch (load_width) {
            case 0x0:
                return new Base<uint8_t>(mn, machInst, rd, rs1);
                break;
            case 0x1:
                return new Base<uint16_t>(mn, machInst, rd, rs1);
                break;
            case 0x2:
                return new Base<uint32_t>(mn, machInst, rd, rs1);
                break;
            default:
                return new Base<uint64_t>(mn, machInst, rd, rs1);
                break;
        }
    }

    template <template<typename Width> class Base>
    StaticInstPtr
    decodeVectorConvTemplatedSigned(  uint8_t load_width,
                                ExtMachInst machInst,
                                uint8_t rd,
                                uint8_t rs1)
    {
        const char* mn = "so.v.cv";
        switch (load_width) {
            case 0x0:
                return new Base<int8_t>(mn, machInst, rd, rs1);
                break;
            case 0x1:
                return new Base<int16_t>(mn, machInst, rd, rs1);
                break;
            case 0x2:
                return new Base<int32_t>(mn, machInst, rd, rs1);
                break;
            default:
                return new Base<int64_t>(mn, machInst, rd, rs1);
                break;
        }
    }

    template <template<typename Width> class Base>
    StaticInstPtr
    decodeVectorConvTemplatedFP(  uint8_t load_width,
                                ExtMachInst machInst,
                                uint8_t rd,
                                uint8_t rs1)
    {
        const char* mn = "so.v.cv";
        switch (load_width) {
            case 0x0:
                return new Unknown(machInst);
                break;
            case 0x1:
                return new Unknown(machInst);
                break;
            case 0x2:
                return new Base<float>(mn, machInst, rd, rs1);
                break;
            default:
                return new Base<double>(mn, machInst, rd, rs1);
                break;
        }
    }

}};


// global let blocks 'let {{...}}' (Python code blocks) are
// executed directly when seen.  Note that these execute in a
// special variable context 'exportContext' to prevent the code
// from polluting this script's namespace. This allows for code
// generation

let {{
    header_output = ''
    exec_output = ''
    decoders = { 'Generic': {} }

    VectorStoreTemplateArgs = VectorLoadTemplateArgs = (
        ('uint8_t',),
        ('uint16_t',),
        ('uint32_t',),
        ('uint64_t',),
    )

    # Generates definitions for UVE vector loads and stores
    def emitUveVectorMemInsts(has_set_bit):
        global header_output, exec_output, decoders
        tplHeader = 'template <class RegElemType>'
        tplArgs = '<RegElemType>'

        # JMNOTE: Here the memAccessSize comes from the value of rs2 ->
        #If its zero: memAccessSize = eCount * sizeOf(RegElemType);
        eaCode = '''
        size = Rs2_ud;
        EA = Rs1_ud;'''

        loadMemAccCode = '''
        for (int i = 0; i < eCount; i++) {
            Vd_x[i] = memDataView[i];
        }
        Vd_x <= width_converter<RegElemType>::width;
        Vd_x <<= memAccessSize;
        '''
        #JMTODO: Change this
        storeMemAccCode = '''
        for (int i = 0; i < eCount; i++) {
            memDataView[i] = Vs1_x[i];
        }
        '''

        set_update_base_address = '''
        Rs1_merge_ud = Rs1_ud + memAccessSize_persistent;
        ''' if has_set_bit else ""


        loadDupIop = InstObjParams('so.v.ld',
            'UveMemLoad' if not has_set_bit else 'UveMemLoadSet',
            'UveBaseMemLoad',
            {'tpl_header': tplHeader,
             'tpl_args': tplArgs,
             'memacc_code': loadMemAccCode,
             'ea_code' : eaCode,
             'set_update_base_address' : set_update_base_address},
            ['IsMemRef', 'IsLoad', 'IsStreamInst'])
        storeDupIop = InstObjParams('so.v.st',
            'UveMemStore' if not has_set_bit else 'UveMemStoreSet',
            'UveBaseMemStore',
            {'tpl_header': tplHeader,
             'tpl_args': tplArgs,
             'memacc_code': storeMemAccCode,
             'ea_code' : eaCode,
             'set_update_base_address' : set_update_base_address},
            ['IsMemRef', 'IsStore', 'IsStreamInst'])


        header_output += UveVectorLoadDeclare.subst(loadDupIop)
        header_output += UveVectorStoreDeclare.subst(storeDupIop)

        exec_output += (
            UveVectorLoadExecute.subst(loadDupIop) +
            UveVectorLoadInitiateAcc.subst(loadDupIop) +
            UveVectorLoadCompleteAcc.subst(loadDupIop) +
            UveVectorStoreExecute.subst(storeDupIop) +
            UveVectorStoreInitiateAcc.subst(storeDupIop) +
            UveVectorStoreCompleteAcc.subst(storeDupIop)
        )

        for args in VectorLoadTemplateArgs:
            substDict = {'tpl_args': '<%s>' % ', '.join(args),
                         'class_name': 'UveMemLoad' if not has_set_bit \
                             else 'UveMemLoadSet'}
            exec_output += UveVectorMemExecDeclare.subst(substDict)

        substDict = {'tpl_args': '<%s>' % 'uint8_t',
                        'class_name': 'UveMemStore' if not has_set_bit \
                            else 'UveMemStoreSet'}
        exec_output += UveVectorMemExecDeclare.subst(substDict)

    emitUveVectorMemInsts(has_set_bit = False)
    emitUveVectorMemInsts(has_set_bit = True)

    def emitUveVectorDup():
        global header_output, exec_output, decoders
        tplHeader = 'template <class RegElemType>'
        tplArgs = '<RegElemType>'

        dupCode = '''
        for (int i = 0; i < eCount; i++) {
            //JMFIXME: This needs to be casted to respective c type
            if(Ps2_x[i])
                Vd_x[i] = Rs1_ud;
        }
        '''

        mvsvCode = '''
            Vd_x[0] = Rs1_ud;
        '''

        DupIop = InstObjParams('so.v.dup',
            'UveVectorDup',
            'UveBaseVectorDup',
            {'tpl_header': tplHeader,
             'tpl_args': tplArgs,
             'ex_code' : dupCode,
             'op_class': 'SimdAluOp'},
            ['IsStreamInst'])

        MvsvIop = InstObjParams('so.v.mvsv',
            'UveVectorMoveSV',
            'UveBaseVectorDup',
            {'tpl_header': tplHeader,
             'tpl_args': tplArgs,
             'ex_code' : mvsvCode,
             'op_class': 'SimdAluOp'},
            ['IsStreamInst'])

        header_output += UveVectorDupDeclare.subst(DupIop)
        header_output += UveVectorDupDeclare.subst(MvsvIop)

        exec_output += UveVectorDupExecute.subst(DupIop)
        exec_output += UveVectorDupExecute.subst(MvsvIop)

        for args in VectorLoadTemplateArgs:
            substDict = {'tpl_args': '<%s>' % ', '.join(args),
                         'class_name': 'UveVectorDup'}
            exec_output += UveVectorExecDeclare.subst(substDict)
            substDict = {'tpl_args': '<%s>' % ', '.join(args),
                         'class_name': 'UveVectorMoveSV'}
            exec_output += UveVectorExecDeclare.subst(substDict)

    emitUveVectorDup()


    def emitUveVectorMove():
        global header_output, exec_output, decoders
        tplHeader = 'template <class RegElemType>'
        tplArgs = '<RegElemType>'

        moveCode = '''
        for (int i = 0; i < eCount; i++) {
            //JMFIXME: This needs to be casted to respective c type
            if(Ps2_x[i])
                Vd_x[i] = Vs1_x[i];
        }
        Vd_x <= Vs1_x.get_width();
        Vd_x <<= Vs1_x.get_valid();
        Vd_x &= Vs1_x.is_last();
        '''

        moveTCode = '''
        for (int i = 0; i < eCount/2; i++) {
            //JMFIXME: This needs to be casted to respective c type
            if(Ps2_x[i]){
                Vd_x[i] = Vs1_x[eCount-1-i];
                Vd_x[eCount-1-i] = Vs1_x[i];
            }
        }
        if(eCount%2==1){
            Vd_x[eCount/2+1] = Vs1_x[eCount/2+1];
        }
        Vd_x <= Vs1_x.get_width();
        Vd_x <<= Vs1_x.get_valid();
        '''

        MoveIop = InstObjParams('so.v.mv',
            'UveVectorMove',
            'UveBaseVectorMove',
            {'tpl_header': tplHeader,
             'tpl_args': tplArgs,
             'ex_code' : moveCode,
             'op_class': 'SimdAluOp'},
            ['IsStreamInst'])

        MoveTIop = InstObjParams('so.v.mvt',
            'UveVectorMoveT',
            'UveBaseVectorMove',
            {'tpl_header': tplHeader,
             'tpl_args': tplArgs,
             'ex_code' : moveTCode,
             'op_class': 'SimdAluOp'},
            ['IsStreamInst'])

        header_output += UveVectorMoveDeclare.subst(MoveIop)
        header_output += UveVectorMoveDeclare.subst(MoveTIop)

        exec_output += (UveVectorMoveExecute.subst(MoveIop) +
                        UveVectorMoveExecute.subst(MoveTIop))

        substDict = {'tpl_args': '<%s>' % 'uint8_t',
                        'class_name': 'UveVectorMove'}
        exec_output += UveVectorExecDeclare.subst(substDict)

        substDict = {'tpl_args': '<%s>' % 'uint8_t',
                        'class_name': 'UveVectorMoveT'}
        exec_output += UveVectorExecDeclare.subst(substDict)

    emitUveVectorMove()

    def emitUveVectorMoveVS():
        global header_output, exec_output, decoders
        tplHeader = 'template <class RegElemType>'
        tplArgs = '<RegElemType>'

        moveVSCode = '''
            auto veccont = (TheISA::VecRegContainer)Vs1_x;
            switch(vector_width){
                case 0:
                    Rd_ud = veccont.as<uint8_t>()[0];
                break;
                case 1:
                    Rd_ud = veccont.as<uint16_t>()[0];
                break;
                case 2:
                    Rd_ud = veccont.as<uint32_t>()[0];
                break;
                default:
                    Rd_ud = veccont.as<uint64_t>()[0];
                break;
            }
        '''

        MoveIop = InstObjParams('so.v.mv',
            'UveVectorMoveVS',
            'UveBaseVectorMoveVS',
            {'tpl_header': tplHeader,
             'tpl_args': tplArgs,
             'ex_code' : moveVSCode,
             'op_class': 'SimdAluOp'},
            ['IsStreamInst'])

        header_output += UveVectorMoveVSDeclare.subst(MoveIop)

        exec_output += UveVectorMoveVSExecute.subst(MoveIop)

        substDict = {'tpl_args': '<%s>' % 'uint8_t',
                        'class_name': 'UveVectorMoveVS'}
        exec_output += UveVectorExecDeclare.subst(substDict)

    emitUveVectorMoveVS()

    UnsignedVectorConvTemplateArgs = (
        ('uint8_t',),
        ('uint16_t',),
        ('uint32_t',),
        ('uint64_t',),
    )
    SignedVectorConvTemplateArgs = (
        ('int8_t',),
        ('int16_t',),
        ('int32_t',),
        ('int64_t',),
    )
    #JMTODO: Need to add 16-bit and 8-bit FP
    FPVectorConvTemplateArgs = (
        ('float',),
        ('double',),
    )
    def emitUveVectorConversion():
        global header_output, exec_output, decoders
        tplHeader = 'template <class RegElemType>'
        tplArgs = '<RegElemType>'

        genericConversion = '''
        auto src_vec_cont = (TheISA::VecRegContainer)Vs1_x;
        if(src_vector_width < dest_vector_width){
            //In this case: e.g. 8->16
            // 1 Copy elems to dest vector
            // 2 Shift elems in the src vector
            switch(src_vector_width){
                case 0:{
                    auto aux_vec = src_vec_cont.as<%(un)sint8_t>();
                    for(int i=0; i<dest_eCount; i++){
                        Vd_x[i] = %(conv_func)s<RegElemType>(aux_vec[i]);
                    }
                    for(int i=0; i<src_eCount - dest_eCount; i++)
                        aux_vec[i] = aux_vec[i+dest_eCount];
                }
                break;
                case 1:{
                    auto aux_vec = src_vec_cont.as<%(un)sint16_t>();
                    for(int i=0; i<dest_eCount; i++){
                        Vd_x[i] = %(conv_func)s<RegElemType>(aux_vec[i]);
                    }
                    for(int i=0; i<src_eCount - dest_eCount; i++)
                        aux_vec[i] = aux_vec[i+dest_eCount];
                }
                break;
                case 2:
                {
                    auto aux_vec = src_vec_cont.as<%(un)sint32_t>();
                    for(int i=0; i<dest_eCount; i++)
                        Vd_x[i] = %(conv_func)s<RegElemType>(aux_vec[i]);
                    for(int i=0; i<src_eCount - dest_eCount; i++)
                        aux_vec[i] = aux_vec[i+dest_eCount];
                }
                break;
            }
            auto aux_vec = src_vec_cont.as<RegElemType>();
            for(int i=0;i<dest_eCount;i++)
                Vs1_merge_x[i] = aux_vec[i];
        }
        else {
            //In this case: e.g. 16->8
            // 1 Shift elems in dest vector
            for(int i=dest_eCount; i>=src_eCount; i--)
                Vd_x[i] = Vd_merge_x[i-src_eCount];
            // 2 Copy elems to dest vector
            switch(src_vector_width){
                case 0:{
                    auto aux_vec = src_vec_cont.as<%(un)sint8_t>();
                    for(int i=0; i<src_eCount; i++)
                        Vd_x[i] = %(conv_func)s<RegElemType>(aux_vec[i]);
                }
                break;
                case 1:
                    {auto aux_vec = src_vec_cont.as<%(un)sint16_t>();
                    for(int i=0; i<src_eCount; i++)
                        Vd_x[i] = %(conv_func)s<RegElemType>(aux_vec[i]);}
                break;
                case 2:
                    {auto aux_vec = src_vec_cont.as<%(un)sint32_t>();
                    for(int i=0; i<src_eCount; i++)
                        Vd_x[i] = %(conv_func)s<RegElemType>(aux_vec[i]);}
                break;
                case 3:
                    {auto aux_vec = src_vec_cont.as<%(un)sint64_t>();
                    for(int i=0; i<src_eCount; i++)
                        Vd_x[i] = %(conv_func)s<RegElemType>(aux_vec[i]);}
                break;
            }
        }
        '''

        unsignedConversion = genericConversion % {'conv_func': 'convertUInt',
                                'un':"u"}

        signedConversion =  genericConversion % {'conv_func': 'convertInt',
                                'un':""}

        fpConversion = '''
        auto src_vec_cont = (TheISA::VecRegContainer)Vs1_x;
        if(src_vector_width < dest_vector_width){
            //In this case: e.g. 8->16
            // 1 Copy elems to dest vector
            // 2 Shift elems in the src vector
            switch(src_vector_width){
                case 2:
                {
                    auto aux_vec = src_vec_cont.as<float>();
                    for(int i=0; i<dest_eCount; i++){
                        DPRINTF(UVEMem, "aux_vec[%%d] = %%#x\\n",i,aux_vec[i]);
                        double tmp = %(conv_func)s<RegElemType>(aux_vec[i]);
                        Vd_x[i] = tmp;
                        DPRINTF(UVEMem, "Vd = %%#x\\n",tmp);
                        }
                    for(int i=0; i<src_eCount - dest_eCount; i++)
                        aux_vec[i] = aux_vec[i+dest_eCount];
                }
                break;
            }
            auto aux_vec = src_vec_cont.as<RegElemType>();
            for(int i=0;i<dest_eCount;i++)
                Vs1_merge_x[i] = aux_vec[i];
        }
        else {
            //In this case: e.g. 16->8
            // 1 Shift elems in dest vector
            for(int i=dest_eCount; i>=src_eCount; i--)
                Vd_x[i] = Vd_merge_x[i-src_eCount];
            // 2 Copy elems to dest vector
            switch(src_vector_width){
                case 2:
                    {auto aux_vec = src_vec_cont.as<float>();
                    for(int i=0; i<src_eCount; i++)
                        Vd_x[i] = %(conv_func)s<RegElemType>(aux_vec[i]);}
                break;
                case 3:
                    {auto aux_vec = src_vec_cont.as<double>();
                    for(int i=0; i<src_eCount; i++)
                        Vd_x[i] = %(conv_func)s<RegElemType>(aux_vec[i]);}
                break;
            }
        }
        ''' % {'conv_func': 'convertFP'}

        for conv in ["Unsigned", "Signed", "FP"]:

            Iop = InstObjParams('so.v.cv',
                'UveVectorConv' + conv,
                'UveBaseVectorConv',
                {'tpl_header': tplHeader,
                'tpl_args': tplArgs,
                'ex_code' : eval(conv.lower() + "Conversion"),
                'op_class': 'SimdAluOp'},
                ['IsStreamInst'])


            header_output += UveVectorConvDeclare.subst(Iop)

            exec_output += UveVectorConvExecute.subst(Iop)

            for args in eval(conv + "VectorConvTemplateArgs"):
                substDict = {'tpl_args': '<%s>' % ', '.join(args),
                            'class_name': 'UveVectorConv'+conv}
                exec_output += UveVectorExecDeclare.subst(substDict)

    emitUveVectorConversion()

}};
