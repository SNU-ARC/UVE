/////////////////////////////////
//
// Uve vector memory operations instructions definition
// -----------------
// Jo√£o Domingos
//

output header {{
    template <template<typename Width> class Base>
    StaticInstPtr
    decodeVectorLoadTemplated(  uint8_t load_width,
                                ExtMachInst machInst,
                                uint8_t rd,
                                uint8_t rs1,
                                uint8_t rs2)
    {
        const char* mn = "so.v.ld";
        switch (load_width) {
            case 0x0:
                return new Base<uint8_t>(mn, machInst, rd, rs1, rs2);
                break;
            case 0x1:
                return new Base<uint16_t>(mn, machInst, rd, rs1, rs2);
                break;
            case 0x2:
                return new Base<uint32_t>(mn, machInst, rd, rs1, rs2);
                break;
            default:
                return new Base<uint64_t>(mn, machInst, rd, rs1, rs2);
                break;
        }
    }

    template <template<typename Width> class Base>
    StaticInstPtr
    decodeVectorStoreTemplated( uint8_t store_width,
                                ExtMachInst machInst,
                                uint8_t rd,
                                uint8_t rs1,
                                uint8_t rs2)
    {
        const char* mn = "so.v.st";
        return new Base<uint8_t>(mn, machInst, rd, rs1, rs2);
    }

    template <template<typename Width> class Base>
    StaticInstPtr
    decodeVectorDupTemplated(  uint8_t load_width,
                                ExtMachInst machInst,
                                uint8_t rd,
                                uint8_t rs1,
                                uint8_t ps2)
    {
        const char* mn = "so.v.dp";
        switch (load_width) {
            case 0x0:
                return new Base<uint8_t>(mn, machInst, rd, rs1, ps2);
                break;
            case 0x1:
                return new Base<uint16_t>(mn, machInst, rd, rs1, ps2);
                break;
            case 0x2:
                return new Base<uint32_t>(mn, machInst, rd, rs1, ps2);
                break;
            default:
                return new Base<uint64_t>(mn, machInst, rd, rs1, ps2);
                break;
        }
    }
}};


// global let blocks 'let {{...}}' (Python code blocks) are
// executed directly when seen.  Note that these execute in a
// special variable context 'exportContext' to prevent the code
// from polluting this script's namespace. This allows for code
// generation

let {{
    header_output = ''
    exec_output = ''
    decoders = { 'Generic': {} }

    VectorStoreTemplateArgs = VectorLoadTemplateArgs = (
        ('uint8_t',),
        ('uint16_t',),
        ('uint32_t',),
        ('uint64_t',),
    )

    # Generates definitions for UVE vector loads and stores
    def emitUveVectorMemInsts(has_set_bit):
        global header_output, exec_output, decoders
        tplHeader = 'template <class RegElemType>'
        tplArgs = '<RegElemType>'

        # JMNOTE: Here the memAccessSize comes from the value of rs2 ->
    #If its zero: memAccessSize = eCount * sizeOf(RegElemType);
        eaCode = '''
        size = Rs2_ud;
        EA = Rs1_ud;'''

        loadMemAccCode = '''
        for (int i = 0; i < eCount; i++) {
            Vd_x[i] = memDataView[i];
        }
        '''

        storeMemAccCode = '''
        for (int i = 0; i < eCount; i++) {
            memDataView[i] = Vs1_x[i];
        }
        '''

        set_update_base_address = '''
        Rs1_merge_ud = Rs1_ud + memAccessSize_persistent;
        ''' if has_set_bit else ""


        loadIop = InstObjParams('so.v.ld',
            'UveMemLoad' if not has_set_bit else 'UveMemLoadSet',
            'UveBaseMemLoad',
            {'tpl_header': tplHeader,
             'tpl_args': tplArgs,
             'memacc_code': loadMemAccCode,
             'ea_code' : eaCode,
             'set_update_base_address' : set_update_base_address},
            ['IsMemRef', 'IsLoad'])
        storeIop = InstObjParams('so.v.st',
            'UveMemStore' if not has_set_bit else 'UveMemStoreSet',
            'UveBaseMemStore',
            {'tpl_header': tplHeader,
             'tpl_args': tplArgs,
             'memacc_code': storeMemAccCode,
             'ea_code' : eaCode,
             'set_update_base_address' : set_update_base_address},
            ['IsMemRef', 'IsStore'])


        header_output += UveVectorLoadDeclare.subst(loadIop)
        header_output += UveVectorStoreDeclare.subst(storeIop)

        exec_output += (
            UveVectorLoadExecute.subst(loadIop) +
            UveVectorLoadInitiateAcc.subst(loadIop) +
            UveVectorLoadCompleteAcc.subst(loadIop) +
            UveVectorStoreExecute.subst(storeIop) +
            UveVectorStoreInitiateAcc.subst(storeIop) +
            UveVectorStoreCompleteAcc.subst(storeIop)
        )

        for args in VectorLoadTemplateArgs:
            substDict = {'tpl_args': '<%s>' % ', '.join(args),
                         'class_name': 'UveMemLoad' if not has_set_bit \
                             else 'UveMemLoadSet'}
            exec_output += UveVectorMemExecDeclare.subst(substDict)

        for args in VectorLoadTemplateArgs:
            substDict = {'tpl_args': '<%s>' % ', '.join(args),
                         'class_name': 'UveMemStore' if not has_set_bit \
                             else 'UveMemStoreSet'}
            exec_output += UveVectorMemExecDeclare.subst(substDict)

    emitUveVectorMemInsts(has_set_bit = False)
    emitUveVectorMemInsts(has_set_bit = True)

    def emitUveVectorDup():
        global header_output, exec_output, decoders
        tplHeader = 'template <class RegElemType>'
        tplArgs = '<RegElemType>'

        dupCode = '''
        for (int i = 0; i < eCount; i++) {
            Vd_x[i] = Rs1_ud;
        }
        '''

        Iop = InstObjParams('so.v.dup',
            'UveVectorDup',
            'UveBaseVectorDup',
            {'tpl_header': tplHeader,
             'tpl_args': tplArgs,
             'ex_code' : dupCode,
             'op_class': 'SimdAluOp'},
            [])

        header_output += UveVectorDupDeclare.subst(Iop)

        exec_output += UveVectorDupExecute.subst(Iop)

        for args in VectorLoadTemplateArgs:
            substDict = {'tpl_args': '<%s>' % ', '.join(args),
                         'class_name': 'UveVectorDup'}
            exec_output += UveVectorExecDeclare.subst(substDict)

    emitUveVectorDup()
}};
