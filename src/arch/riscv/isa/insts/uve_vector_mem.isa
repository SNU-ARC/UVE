/////////////////////////////////
//
// Uve vector memory operations instructions definition
// -----------------
// Jo√£o Domingos
//

output header {{
    template <template<typename Width> class Base>
    StaticInstPtr
    decodeVectorLoadTemplated(  uint8_t load_width,
                                ExtMachInst machInst,
                                uint8_t rd,
                                uint8_t rs1,
                                uint8_t rs2)
    {
        const char* mn = "so.v.ld";
        switch (load_width) {
            case 0x0:
                return new Base<uint8_t>(mn, machInst, rd, rs1, rs2);
                break;
            case 0x1:
                return new Base<uint16_t>(mn, machInst, rd, rs1, rs2);
                break;
            case 0x2:
                return new Base<uint32_t>(mn, machInst, rd, rs1, rs2);
                break;
            default:
                return new Base<uint64_t>(mn, machInst, rd, rs1, rs2);
                break;
        }
    }

    template <template<typename Width> class Base>
    StaticInstPtr
    decodeVectorStoreTemplated(ExtMachInst machInst,
                                uint8_t rd,
                                uint8_t rs1,
                                uint8_t rs2)
    {
        const char* mn = "so.v.st";
        return new Base<uint8_t>(mn, machInst, rd, rs1, rs2);
    }

    template <template<typename Width> class Base>
    StaticInstPtr
    decodeVectorDupTemplated(  uint8_t load_width,
                                ExtMachInst machInst,
                                uint8_t rd,
                                uint8_t rs1,
                                uint8_t ps2)
    {
        const char* mn = "so.v.dp";
        switch (load_width) {
            case 0x0:
                return new Base<uint8_t>(mn, machInst, rd, rs1, ps2);
                break;
            case 0x1:
                return new Base<uint16_t>(mn, machInst, rd, rs1, ps2);
                break;
            case 0x2:
                return new Base<uint32_t>(mn, machInst, rd, rs1, ps2);
                break;
            default:
                return new Base<uint64_t>(mn, machInst, rd, rs1, ps2);
                break;
        }
    }

    template <template<typename Width> class Base>
    StaticInstPtr
    decodeVectorMoveSVTemplated(  uint8_t load_width,
                                ExtMachInst machInst,
                                uint8_t rd,
                                uint8_t rs1,
                                uint8_t ps2 = 0)
    {
        const char* mn = "so.v.mvsv";
        switch (load_width) {
            case 0x0:
                return new Base<uint8_t>(mn, machInst, rd, rs1, ps2);
                break;
            case 0x1:
                return new Base<uint16_t>(mn, machInst, rd, rs1, ps2);
                break;
            case 0x2:
                return new Base<uint32_t>(mn, machInst, rd, rs1, ps2);
                break;
            default:
                return new Base<uint64_t>(mn, machInst, rd, rs1, ps2);
                break;
        }
    }

    template <template<typename Width> class Base>
    StaticInstPtr
    decodeVectorMoveTemplated(ExtMachInst machInst,
                                uint8_t rd,
                                uint8_t rs1,
                                uint8_t ps2)
    {
        const char* mn = "so.v.mv";
        return new Base<uint8_t>(mn, machInst, rd, rs1, ps2);
    }

    template <template<typename Width> class Base>
    StaticInstPtr
    decodeVectorMoveVSTemplated(ExtMachInst machInst,
                                uint8_t rd,
                                uint8_t rs1,
                                uint8_t ps2 = 0)
    {
        const char* mn = "so.v.mvvs";
        return new Base<uint8_t>(mn, machInst, rd, rs1, ps2);
    }
}};


// global let blocks 'let {{...}}' (Python code blocks) are
// executed directly when seen.  Note that these execute in a
// special variable context 'exportContext' to prevent the code
// from polluting this script's namespace. This allows for code
// generation

let {{
    header_output = ''
    exec_output = ''
    decoders = { 'Generic': {} }

    VectorStoreTemplateArgs = VectorLoadTemplateArgs = (
        ('uint8_t',),
        ('uint16_t',),
        ('uint32_t',),
        ('uint64_t',),
    )

    # Generates definitions for UVE vector loads and stores
    def emitUveVectorMemInsts(has_set_bit):
        global header_output, exec_output, decoders
        tplHeader = 'template <class RegElemType>'
        tplArgs = '<RegElemType>'

        # JMNOTE: Here the memAccessSize comes from the value of rs2 ->
    #If its zero: memAccessSize = eCount * sizeOf(RegElemType);
        eaCode = '''
        size = Rs2_ud;
        EA = Rs1_ud;'''

        loadMemAccCode = '''
        for (int i = 0; i < eCount; i++) {
            Vd_x[i] = memDataView[i];
        }
        '''

        storeMemAccCode = '''
        for (int i = 0; i < eCount; i++) {
            memDataView[i] = Vs1_x[i];
        }
        '''

        set_update_base_address = '''
        Rs1_merge_ud = Rs1_ud + memAccessSize_persistent;
        ''' if has_set_bit else ""


        loadDupIop = InstObjParams('so.v.ld',
            'UveMemLoad' if not has_set_bit else 'UveMemLoadSet',
            'UveBaseMemLoad',
            {'tpl_header': tplHeader,
             'tpl_args': tplArgs,
             'memacc_code': loadMemAccCode,
             'ea_code' : eaCode,
             'set_update_base_address' : set_update_base_address},
            ['IsMemRef', 'IsLoad'])
        storeDupIop = InstObjParams('so.v.st',
            'UveMemStore' if not has_set_bit else 'UveMemStoreSet',
            'UveBaseMemStore',
            {'tpl_header': tplHeader,
             'tpl_args': tplArgs,
             'memacc_code': storeMemAccCode,
             'ea_code' : eaCode,
             'set_update_base_address' : set_update_base_address},
            ['IsMemRef', 'IsStore'])


        header_output += UveVectorLoadDeclare.subst(loadDupIop)
        header_output += UveVectorStoreDeclare.subst(storeDupIop)

        exec_output += (
            UveVectorLoadExecute.subst(loadDupIop) +
            UveVectorLoadInitiateAcc.subst(loadDupIop) +
            UveVectorLoadCompleteAcc.subst(loadDupIop) +
            UveVectorStoreExecute.subst(storeDupIop) +
            UveVectorStoreInitiateAcc.subst(storeDupIop) +
            UveVectorStoreCompleteAcc.subst(storeDupIop)
        )

        for args in VectorLoadTemplateArgs:
            substDict = {'tpl_args': '<%s>' % ', '.join(args),
                         'class_name': 'UveMemLoad' if not has_set_bit \
                             else 'UveMemLoadSet'}
            exec_output += UveVectorMemExecDeclare.subst(substDict)

        substDict = {'tpl_args': '<%s>' % 'uint8_t',
                        'class_name': 'UveMemStore' if not has_set_bit \
                            else 'UveMemStoreSet'}
        exec_output += UveVectorMemExecDeclare.subst(substDict)

    emitUveVectorMemInsts(has_set_bit = False)
    emitUveVectorMemInsts(has_set_bit = True)

    def emitUveVectorDup():
        global header_output, exec_output, decoders
        tplHeader = 'template <class RegElemType>'
        tplArgs = '<RegElemType>'

        dupCode = '''
        for (int i = 0; i < eCount; i++) {
            if(Ps2_x[i])
                Vd_x[i] = Rs1_ud;
        }
        '''

        mvsvCode = '''
            Vd_x[0] = Rs1_ud;
        '''

        DupIop = InstObjParams('so.v.dup',
            'UveVectorDup',
            'UveBaseVectorDup',
            {'tpl_header': tplHeader,
             'tpl_args': tplArgs,
             'ex_code' : dupCode,
             'op_class': 'SimdAluOp'},
            [])

        MvsvIop = InstObjParams('so.v.mvsv',
            'UveVectorMoveSV',
            'UveBaseVectorDup',
            {'tpl_header': tplHeader,
             'tpl_args': tplArgs,
             'ex_code' : mvsvCode,
             'op_class': 'SimdAluOp'},
            [])

        header_output += UveVectorDupDeclare.subst(DupIop)
        header_output += UveVectorDupDeclare.subst(MvsvIop)

        exec_output += UveVectorDupExecute.subst(DupIop)
        exec_output += UveVectorDupExecute.subst(MvsvIop)

        for args in VectorLoadTemplateArgs:
            substDict = {'tpl_args': '<%s>' % ', '.join(args),
                         'class_name': 'UveVectorDup'}
            exec_output += UveVectorExecDeclare.subst(substDict)
            substDict = {'tpl_args': '<%s>' % ', '.join(args),
                         'class_name': 'UveVectorMoveSV'}
            exec_output += UveVectorExecDeclare.subst(substDict)

    emitUveVectorDup()


    def emitUveVectorMove():
        global header_output, exec_output, decoders
        tplHeader = 'template <class RegElemType>'
        tplArgs = '<RegElemType>'

        moveCode = '''
        for (int i = 0; i < eCount; i++) {
            if(Ps2_x[i])
                Vd_x[i] = Vs1_x[i];
        }
        '''

        moveTCode = '''
        for (int i = 0; i < eCount/2; i++) {
            if(Ps2_x[i]){
                Vd_x[i] = Vs1_x[eCount-1-i];
                Vd_x[eCount-1-i] = Vs1_x[i];
            }
        }
        if(eCount%2==1){
            Vd_x[eCount/2+1] = Vs1_x[eCount/2+1];
        }
        '''

        MoveIop = InstObjParams('so.v.mv',
            'UveVectorMove',
            'UveBaseVectorMove',
            {'tpl_header': tplHeader,
             'tpl_args': tplArgs,
             'ex_code' : moveCode,
             'op_class': 'SimdAluOp'},
            [])

        MoveTIop = InstObjParams('so.v.mvt',
            'UveVectorMoveT',
            'UveBaseVectorMove',
            {'tpl_header': tplHeader,
             'tpl_args': tplArgs,
             'ex_code' : moveTCode,
             'op_class': 'SimdAluOp'},
            [])

        header_output += UveVectorMoveDeclare.subst(MoveIop)
        header_output += UveVectorMoveDeclare.subst(MoveTIop)

        exec_output += (UveVectorMoveExecute.subst(MoveIop) +
                        UveVectorMoveExecute.subst(MoveTIop))

        substDict = {'tpl_args': '<%s>' % 'uint8_t',
                        'class_name': 'UveVectorMove'}
        exec_output += UveVectorExecDeclare.subst(substDict)

        substDict = {'tpl_args': '<%s>' % 'uint8_t',
                        'class_name': 'UveVectorMoveT'}
        exec_output += UveVectorExecDeclare.subst(substDict)

    emitUveVectorMove()

    def emitUveVectorMoveVS():
        global header_output, exec_output, decoders
        tplHeader = 'template <class RegElemType>'
        tplArgs = '<RegElemType>'

        moveVSCode = '''
            auto veccont = (TheISA::VecRegContainer)Vs1_x;
            switch(vector_width){
                case 0:
                    Rd_ud = veccont.as<uint8_t>()[0];
                break;
                case 1:
                    Rd_ud = veccont.as<uint16_t>()[0];
                break;
                case 2:
                    Rd_ud = veccont.as<uint32_t>()[0];
                break;
                default:
                    Rd_ud = veccont.as<uint64_t>()[0];
                break;
            }
        '''

        MoveIop = InstObjParams('so.v.mv',
            'UveVectorMoveVS',
            'UveBaseVectorMoveVS',
            {'tpl_header': tplHeader,
             'tpl_args': tplArgs,
             'ex_code' : moveVSCode,
             'op_class': 'SimdAluOp'},
            [])

        header_output += UveVectorMoveVSDeclare.subst(MoveIop)

        exec_output += UveVectorMoveVSExecute.subst(MoveIop)

        substDict = {'tpl_args': '<%s>' % 'uint8_t',
                        'class_name': 'UveVectorMoveVS'}
        exec_output += UveVectorExecDeclare.subst(substDict)

    emitUveVectorMoveVS()

}};
