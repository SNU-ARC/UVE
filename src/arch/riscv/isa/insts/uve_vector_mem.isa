/////////////////////////////////
//
// Uve vector memory operations instructions definition
// -----------------
// Jo√£o Domingos
//

output header {{
    template <template<typename Width> class Base>
    StaticInstPtr
    decodeVectorLoadTemplated(  uint8_t load_width,
                                ExtMachInst machInst,
                                IntRegIndex rd, 
                                IntRegIndex rs1,
                                IntRegIndex rs2)
    {
        const char* mn = "so.v.ld";
        switch (load_width) {
            case 0x0:
                return new Base<uint8_t>(mn, machInst, rd, rs1, rs2);
                break;
            case 0x1:
                return new Base<uint16_t>(mn, machInst, rd, rs1, rs2);
                break;
            case 0x2:
                return new Base<uint32_t>(mn, machInst, rd, rs1, rs2);
                break;
            case 0x3:
                return new Base<uint64_t>(mn, machInst, rd, rs1, rs2);
                break;
        }
    }
    
    template <template<typename Width> class Base>
    StaticInstPtr
    decodeVectorStoreTemplated( uint8_t store_width,
                                ExtMachInst machInst,
                                IntRegIndex rd, 
                                IntRegIndex rs1,
                                IntRegIndex rs2)
    {
        const char* mn = "so.v.st";
        switch (store_width) {
            case 0x0:
                return new Base<uint8_t>(mn, machInst, rd, rs1, rs2);
                break;
            case 0x1:
                return new Base<uint16_t>(mn, machInst, rd, rs1, rs2);
                break;
            case 0x2:
                return new Base<uint32_t>(mn, machInst, rd, rs1, rs2);
                break;
            case 0x3:
                return new Base<uint64_t>(mn, machInst, rd, rs1, rs2);
                break;
        }
    }
}};


// global let blocks 'let {{...}}' (Python code blocks) are
// executed directly when seen.  Note that these execute in a
// special variable context 'exportContext' to prevent the code
// from polluting this script's namespace. This allows for code 
// generation

let {{
    header_output = ''
    exec_output = ''
    decoders = { 'Generic': {} }

    VectorStoreTemplateArgs = VectorLoadTemplateArgs = (
        ('uint8_t',),
        ('uint16_t',),
        ('uint32_t',),
        ('uint64_t',),
    )

    # Generates definitions for UVE vector loads and stores
    def emitUveVectorMemInsts(has_set_bit):
        global header_output, exec_output, decoders
        tplHeader = 'template <class RegElemType>'
        tplArgs = '<RegElemType>'

        # JMNOTE: Here the memAccessSize comes from the value of rs2 -> If its zero: memAccessSize = eCount * sizeOf(RegElemType);
        eaCode = '''
        if(Rs2_ud != 0){
            eCount = Rs2_ud;
        }
        
        int memAccessSize = eCount * sizeof(RegElemType);
        EA = Rs1_ud;'''
        
        loadRdEnableCode = '''
        auto rdEn = std::vector<bool>(sizeof(RegElemType) * eCount, true);
        '''
        loadMemAccCode = '''
        for (int i = 0; i < eCount; i++) {
            Vd_x[i] = memDataView[i];
        }
        '''
        
        storeMemAccCode = '''
        for (int i = 0; i < eCount; i++) {
            memDataView[i] = Vs1_x[i];
        }
        '''
        storeWrEnableCode = '''
        auto wrEn = std::vector<bool>(sizeof(RegElemType) * eCount, true);
        '''

        set_update_base_address = '''
        Rs1_merge_ud += eCount * sizeof(RegElemType);
        ''' if has_set_bit else ""


        loadIop = InstObjParams('so.v.ld',
            'UveLoad' if not has_set_bit else 'UveLoadSet',
            'UveMem',
            {'tpl_header': tplHeader,
             'tpl_args': tplArgs,
             'rden_code' : loadRdEnableCode,
             'memacc_code': loadMemAccCode,
             'ea_code' : eaCode,
             'set_update_base_address' : set_update_base_address},
            ['IsMemRef', 'IsLoad'])
        storeIop = InstObjParams('so.v.st',
            'UveStore' if not has_set_bit else 'UveStoreSet',
            'UveMem',
            {'tpl_header': tplHeader,
             'tpl_args': tplArgs,
             'wren_code': storeWrEnableCode,
             'memacc_code': storeMemAccCode,
             'ea_code' : eaCode,
             'set_update_base_address' : set_update_base_address},
            ['IsMemRef', 'IsStore'])
       
       
        header_output += UveMemLoadDeclare.subst(loadIop)
        header_output += UveMemStoreDeclare.subst(storeIop)

        exec_output += (
            UveLoadExecute.subst(loadIop) +
            UveLoadInitiateAcc.subst(loadIop) +
            UveLoadCompleteAcc.subst(loadIop) +
            UveStoreExecute.subst(storeIop) +
            UveStoreInitiateAcc.subst(storeIop) +
            UveStoreCompleteAcc.subst(storeIop)
        )

        for args in VectorLoadTemplateArgs:
            substDict = {'tpl_args': '<%s>' % ', '.join(args),
                         'class_name': 'UveLoad' if not has_set_bit else 'UveLoadSet'}
            exec_output += UveMemExecDeclare.subst(substDict)

        for args in VectorLoadTemplateArgs:
            substDict = {'tpl_args': '<%s>' % ', '.join(args),
                         'class_name': 'UveStore' if not has_set_bit else 'UveStoreSet'}
            exec_output += UveMemExecDeclare.subst(substDict)

    emitUveVectorMemInsts(has_set_bit = False)
    emitUveVectorMemInsts(has_set_bit = True)
    # JMTODO: emitUveVectorMemInsts with set_bit as true
}};
